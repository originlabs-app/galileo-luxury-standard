---
phase: 05-token-compliance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - specifications/contracts/compliance/IModularCompliance.sol
  - specifications/contracts/compliance/IGalileoCompliance.sol
  - specifications/contracts/compliance/IComplianceModule.sol
  - specifications/contracts/compliance/modules/IBrandAuthorizationModule.sol
  - specifications/contracts/compliance/modules/ICPOCertificationModule.sol
  - specifications/contracts/compliance/modules/IServiceCenterModule.sol
autonomous: true

must_haves:
  truths:
    - "Compliance interface extends ERC-3643 modular compliance pattern"
    - "Modules can be added/removed dynamically without token redeployment"
    - "canTransfer aggregates all bound module checks"
    - "Luxury-specific modules enforce brand authorization rules"
  artifacts:
    - path: "specifications/contracts/compliance/IModularCompliance.sol"
      provides: "Re-exported ERC-3643 IModularCompliance"
      contains: "import.*@erc3643org/erc-3643"
    - path: "specifications/contracts/compliance/IGalileoCompliance.sol"
      provides: "Extended compliance with batch checks"
      exports: ["IGalileoCompliance"]
      min_lines: 80
    - path: "specifications/contracts/compliance/IComplianceModule.sol"
      provides: "Module interface for pluggable rules"
      exports: ["IComplianceModule"]
      min_lines: 60
    - path: "specifications/contracts/compliance/modules/IBrandAuthorizationModule.sol"
      provides: "Brand authorization checking"
      min_lines: 40
  key_links:
    - from: "specifications/contracts/compliance/IGalileoCompliance.sol"
      to: "@erc3643org/erc-3643/contracts/compliance/IModularCompliance.sol"
      via: "interface inheritance"
      pattern: "interface IGalileoCompliance is IModularCompliance"
    - from: "specifications/contracts/compliance/modules/IBrandAuthorizationModule.sol"
      to: "specifications/contracts/identity/IClaimTopicsRegistry.sol"
      via: "GalileoClaimTopics.AUTHORIZED_RETAILER usage"
      pattern: "AUTHORIZED_RETAILER"
---

<objective>
Create modular compliance interfaces for pluggable transfer rules with luxury-specific modules.

Purpose: Enable dynamic compliance configuration where brands can add/remove compliance rules without redeploying tokens. Support luxury-specific rules like brand authorization, CPO certification requirements, and service center validation.

Output: Solidity interfaces for modular compliance contracts and three luxury-specific compliance modules.
</objective>

<execution_context>
@/Users/pierrebeunardeau/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pierrebeunardeau/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-token-compliance/05-RESEARCH.md
@specifications/contracts/identity/IIdentityRegistry.sol
@specifications/contracts/identity/IClaimTopicsRegistry.sol
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create compliance base interfaces</name>
  <files>
    specifications/contracts/compliance/IModularCompliance.sol
    specifications/contracts/compliance/IGalileoCompliance.sol
    specifications/contracts/compliance/IComplianceModule.sol
  </files>
  <action>
Create three interconnected compliance interfaces:

**1. IModularCompliance.sol** - Re-export ERC-3643 interface with documentation:
- Import from `@erc3643org/erc-3643/contracts/compliance/IModularCompliance.sol`
- Document key functions:
  - `bindToken(address)` / `unbindToken(address)` - Token binding
  - `addModule(address)` / `removeModule(address)` - Module management
  - `getModules()` - List bound modules
  - `canTransfer(from, to, amount)` - Aggregate compliance check
  - `transferred(from, to, amount)` - Post-transfer notification
  - `created(to, amount)` / `destroyed(from, amount)` - Mint/burn notifications

**2. IGalileoCompliance.sol** - Extended compliance interface:
```solidity
interface IGalileoCompliance is IModularCompliance {
    // Transfer check with detailed reason
    function canTransferWithReason(
        address _from,
        address _to,
        uint256 _amount
    ) external view returns (bool allowed, string memory reason, address failingModule);

    // Batch compliance check (gas efficient for multi-transfer)
    function canTransferBatch(
        address[] calldata _from,
        address[] calldata _to,
        uint256[] calldata _amounts
    ) external view returns (bool[] memory results);

    // Module introspection
    function getModulesByType(bytes4 moduleType) external view returns (address[] memory);
    function isModuleEnabled(address module) external view returns (bool);
    function moduleCount() external view returns (uint256);

    // Events
    event ModuleAdded(address indexed module, bytes4 moduleType);
    event ModuleRemoved(address indexed module);
    event ComplianceCheckFailed(address indexed from, address indexed to, address indexed failingModule);
}
```

**3. IComplianceModule.sol** - Base module interface:
```solidity
interface IComplianceModule {
    // Module type identifier (for filtering)
    function moduleType() external pure returns (bytes4);

    // Module name and version
    function name() external pure returns (string memory);
    function version() external pure returns (string memory);

    // Core compliance check
    function moduleCheck(
        address _from,
        address _to,
        uint256 _value,
        address _compliance
    ) external view returns (bool);

    // Lifecycle hooks
    function moduleMintAction(address _to, uint256 _value, address _compliance) external;
    function moduleBurnAction(address _from, uint256 _value, address _compliance) external;
    function moduleTransferAction(address _from, address _to, uint256 _value, address _compliance) external;

    // Compliance binding
    function bindCompliance(address _compliance) external;
    function unbindCompliance(address _compliance) external;
    function isComplianceBound(address _compliance) external view returns (bool);
}
```

Include module type constants:
```solidity
bytes4 constant MODULE_TYPE_JURISDICTION = bytes4(keccak256("JURISDICTION"));
bytes4 constant MODULE_TYPE_BALANCE = bytes4(keccak256("BALANCE"));
bytes4 constant MODULE_TYPE_TIME = bytes4(keccak256("TIME"));
bytes4 constant MODULE_TYPE_ROLE = bytes4(keccak256("ROLE"));
bytes4 constant MODULE_TYPE_SANCTIONS = bytes4(keccak256("SANCTIONS"));
bytes4 constant MODULE_TYPE_BRAND = bytes4(keccak256("BRAND"));
```
  </action>
  <verify>All three files exist with correct imports and NatSpec documentation.</verify>
  <done>Compliance base interfaces provide modular, extensible compliance architecture.</done>
</task>

<task type="auto">
  <name>Task 2: Create luxury-specific compliance modules</name>
  <files>
    specifications/contracts/compliance/modules/IBrandAuthorizationModule.sol
    specifications/contracts/compliance/modules/ICPOCertificationModule.sol
    specifications/contracts/compliance/modules/IServiceCenterModule.sol
  </files>
  <action>
Create three Galileo-specific compliance module interfaces:

**1. IBrandAuthorizationModule.sol** - Ensures transfers go through authorized retailers:
```solidity
interface IBrandAuthorizationModule is IComplianceModule {
    // Brand authorization checking
    function brandDID() external view returns (string memory);
    function isAuthorizedRetailer(address _address) external view returns (bool);
    function isAuthorizedForCategory(address _address, string calldata _category) external view returns (bool);

    // Configuration (restricted to brand admin)
    function setAuthorizedRetailerClaimTopic(uint256 _claimTopic) external;
    function setRequireRetailerForPrimarySale(bool _require) external;

    // Query claim topic used
    function authorizedRetailerClaimTopic() external view returns (uint256);

    // Events
    event RetailerAuthorizationChecked(address indexed retailer, bool authorized);
    event ClaimTopicUpdated(uint256 oldTopic, uint256 newTopic);
}
```

Note: References GalileoClaimTopics.AUTHORIZED_RETAILER (0xfc1ed254...) from Phase 4.

**2. ICPOCertificationModule.sol** - Requires CPO certification for resale:
```solidity
interface ICPOCertificationModule is IComplianceModule {
    // CPO requirement modes
    enum CPOMode {
        NOT_REQUIRED,          // CPO not required for transfers
        REQUIRED_FOR_RESALE,   // CPO required only for secondary sales
        ALWAYS_REQUIRED        // CPO required for all transfers
    }

    // CPO checking
    function cpoMode() external view returns (CPOMode);
    function isCPORequired(address from, address to) external view returns (bool);
    function hasCPOCertification(address token) external view returns (bool);

    // Configuration
    function setCPOMode(CPOMode _mode) external;
    function addTrustedCertifier(address _certifier) external;
    function removeTrustedCertifier(address _certifier) external;
    function isTrustedCertifier(address _certifier) external view returns (bool);

    // Events
    event CPOModeUpdated(CPOMode oldMode, CPOMode newMode);
    event TrustedCertifierAdded(address indexed certifier);
    event TrustedCertifierRemoved(address indexed certifier);
    event CPOCheckFailed(address indexed token, address indexed from, address indexed to);
}
```

**3. IServiceCenterModule.sol** - Validates service center authorization:
```solidity
interface IServiceCenterModule is IComplianceModule {
    // Service center verification
    function isAuthorizedServiceCenter(address _address) external view returns (bool);
    function isAuthorizedForServiceType(address _address, bytes32 _serviceType) external view returns (bool);

    // Service type constants
    function SERVICE_TYPE_REPAIR() external pure returns (bytes32);
    function SERVICE_TYPE_RESTORATION() external pure returns (bytes32);
    function SERVICE_TYPE_AUTHENTICATION() external pure returns (bytes32);

    // Configuration
    function setServiceCenterClaimTopic(uint256 _claimTopic) external;
    function serviceCenterClaimTopic() external view returns (uint256);

    // For MRO (Maintenance, Repair, Overhaul) transfers
    function validateMROTransfer(
        address _from,
        address _serviceCenter,
        bytes32 _serviceType
    ) external view returns (bool);

    // Events
    event ServiceCenterValidated(address indexed center, bytes32 serviceType, bool authorized);
    event MROTransferValidated(address indexed from, address indexed serviceCenter, bytes32 serviceType);
}
```

All modules should:
- Extend IComplianceModule
- Reference appropriate GalileoClaimTopics constants
- Include comprehensive NatSpec
- Define custom errors for failure cases
  </action>
  <verify>All three module interfaces exist and reference Phase 4 claim topics.</verify>
  <done>Luxury-specific modules enforce brand authorization, CPO, and service center rules.</done>
</task>

</tasks>

<verification>
All compliance interfaces and modules exist:

```bash
ls -la specifications/contracts/compliance/
ls -la specifications/contracts/compliance/modules/
```

Check for correct inheritance:
```bash
grep -r "extends IModularCompliance" specifications/contracts/compliance/
grep -r "extends IComplianceModule" specifications/contracts/compliance/modules/
```

Validate Phase 4 integration:
```bash
grep -r "GalileoClaimTopics\|AUTHORIZED_RETAILER\|SERVICE_CENTER" specifications/contracts/compliance/modules/
```
</verification>

<success_criteria>
1. IModularCompliance.sol re-exports ERC-3643 with comprehensive documentation
2. IGalileoCompliance.sol extends with batch checks and module introspection
3. IComplianceModule.sol defines base module interface with lifecycle hooks
4. IBrandAuthorizationModule.sol enforces authorized retailer requirements
5. ICPOCertificationModule.sol enforces CPO certification for resale
6. IServiceCenterModule.sol validates service center authorization for MRO
7. All modules reference Phase 4 GalileoClaimTopics constants
8. All files use Apache-2.0 license and Solidity ^0.8.20
</success_criteria>

<output>
After completion, create `.planning/phases/05-token-compliance/05-02-SUMMARY.md`
</output>
