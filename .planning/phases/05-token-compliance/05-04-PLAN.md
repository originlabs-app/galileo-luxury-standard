---
phase: 05-token-compliance
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - specifications/compliance/jurisdiction-rules.md
  - specifications/token/ownership-transfer.md
  - specifications/contracts/compliance/modules/IJurisdictionModule.sol
autonomous: true

must_haves:
  truths:
    - "Jurisdiction rules enable country-based transfer restrictions"
    - "Ownership transfer specification covers primary sale, resale, and MRO flows"
    - "Transfer flows integrate compliance, identity, and token interfaces"
    - "Export control restrictions block transfers to prohibited countries"
  artifacts:
    - path: "specifications/compliance/jurisdiction-rules.md"
      provides: "Jurisdiction restriction schema"
      contains: "CountryAllowModule\|CountryRestrictModule"
      min_lines: 120
    - path: "specifications/token/ownership-transfer.md"
      provides: "Complete transfer flow specification"
      contains: "identityRegistry.isVerified"
      min_lines: 180
    - path: "specifications/contracts/compliance/modules/IJurisdictionModule.sol"
      provides: "Jurisdiction restriction interface"
      min_lines: 60
  key_links:
    - from: "specifications/token/ownership-transfer.md"
      to: "specifications/contracts/token/IGalileoToken.sol"
      via: "transfer flow reference"
      pattern: "IGalileoToken"
    - from: "specifications/token/ownership-transfer.md"
      to: "specifications/contracts/compliance/IGalileoCompliance.sol"
      via: "compliance check integration"
      pattern: "canTransfer"
---

<objective>
Create jurisdiction restriction schema and complete ownership transfer specification for luxury goods.

Purpose: Enable country-based transfer restrictions for export controls and specify complete transfer flows covering primary sale, resale (with CPO), and service/repair transfers.

Output: Specification documents for jurisdiction rules and ownership transfer, plus Solidity interface for jurisdiction compliance module.
</objective>

<execution_context>
@/Users/pierrebeunardeau/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pierrebeunardeau/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-token-compliance/05-RESEARCH.md
@specifications/contracts/identity/IIdentityRegistry.sol
@specifications/contracts/identity/IClaimTopicsRegistry.sol
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create jurisdiction rules specification</name>
  <files>specifications/compliance/jurisdiction-rules.md</files>
  <action>
Create a comprehensive specification document for jurisdiction-based transfer restrictions.

Document structure:

**1. Overview**
- Purpose of jurisdiction restrictions in luxury goods transfers
- Regulatory drivers (export controls, sanctions, territory rights)
- ERC-3643 CountryAllowModule and CountryRestrictModule as base patterns

**2. Country Code Standard**

Reference ISO 3166-1 numeric codes (uint16):
| Country | Code |
|---------|------|
| United States | 840 |
| France | 250 |
| China | 156 |
| Russia | 643 |
| North Korea | 408 |

Note: Country code stored in Identity Registry via registerIdentity(address, IIdentity, uint16 country)

**3. Restriction Modes**

Two modes following ERC-3643 patterns:

**Allow Mode (CountryAllowModule pattern):**
- Only specified countries can receive transfers
- Use case: Territory-limited product launches
- Example: Japan-exclusive watch edition

**Restrict Mode (CountryRestrictModule pattern):**
- Specified countries cannot receive transfers
- Use case: Export control compliance
- Example: Sanctioned country blocking

**4. Brand-Specific Territory Rights**

Schema for brand territory configuration:
```json
{
  "brandDID": "did:galileo:brand:hermes",
  "product": {
    "category": "leather_goods",
    "territories": {
      "mode": "allow",
      "countries": [250, 276, 380, 826, 840],
      "reason": "Initial launch territories"
    }
  }
}
```

**5. Export Control Lists**

Integration with export control regimes:
| Regime | Source | Update Frequency |
|--------|--------|------------------|
| OFAC SDN | US Treasury | Daily |
| EU Consolidated | European Commission | Weekly |
| UN Security Council | United Nations | As published |

**6. Country Group Definitions**

Predefined country groups:
- `OFAC_SANCTIONED`: Countries under comprehensive US sanctions
- `EU_SANCTIONED`: Countries under EU sanctions
- `FATF_GREYLIST`: FATF grey list countries (enhanced due diligence)
- `OECD_MEMBERS`: OECD member countries
- `EU_MEMBERS`: European Union member states
- `APAC_DEVELOPED`: Developed APAC markets

**7. Conflict Resolution**

When multiple rules apply:
1. Sanctioned country blocks always win (highest priority)
2. Brand-specific restrictions second
3. Product-specific restrictions third
4. Default: allow transfer

**8. Country Code Verification Flow**

```
Transfer requested
       |
       v
[Get receiver country from Identity Registry]
       |
       v
[Check sanctions list] --> BLOCKED: Sanctioned country
       |
       (pass)
       v
[Check brand restrictions] --> BLOCKED: Territory violation
       |
       (pass)
       v
[Check product restrictions] --> BLOCKED: Product territory
       |
       (pass)
       v
ALLOWED
```

**9. Events for Compliance Audit**

- `JurisdictionCheckPerformed(address indexed receiver, uint16 country, bool allowed)`
- `TransferBlockedJurisdiction(address indexed from, address indexed to, uint16 country, string reason)`
- `CountryRestrictionUpdated(uint16[] countries, bool restricted)`

**10. Dynamic Restriction Updates**

Process for updating restrictions:
1. Regulatory change detected
2. Compliance team reviews
3. TSC approval for global changes (or brand admin for brand-specific)
4. On-chain update with event emission
5. Affected transfers immediately blocked
  </action>
  <verify>Document exists with ISO 3166-1 references, allow/restrict modes, and export control integration.</verify>
  <done>Jurisdiction rules specification enables country-based transfer restrictions.</done>
</task>

<task type="auto">
  <name>Task 2: Create ownership transfer specification</name>
  <files>specifications/token/ownership-transfer.md</files>
  <action>
Create a comprehensive specification document for ownership transfer flows.

Document structure:

**1. Overview**
- Purpose of ownership transfer specification
- Single-supply token pattern (one token = one product)
- Integration of identity, compliance, and token layers

**2. Transfer Validation Sequence**

Complete validation flow (from ERC-3643 research):
```
transfer(to, amount) called
       |
       v
[1. Check global pause status]
   └── If paused, revert TokenPaused
       |
       v
[2. Check address freeze status]
   └── If sender OR receiver frozen, revert AddressFrozen
       |
       v
[3. Check partial freeze (sender balance)]
   └── If amount > (balance - frozenTokens), revert InsufficientUnfrozenBalance
       |
       v
[4. Identity Registry verification]
   └── identityRegistry.isVerified(receiver) must be true
   └── Checks: registered identity + required claims from trusted issuers
       |
       v
[5. Compliance check]
   └── compliance.canTransfer(from, to, amount) must return true
   └── Evaluates ALL bound compliance modules
       |
       v
[6. Execute transfer (update balances)]
       |
       v
[7. Post-transfer notification]
   └── compliance.transferred(from, to, amount)
   └── Modules update internal state
```

**3. Primary Sale Flow**

Brand to Authorized Retailer:
```
Brand Wallet --> [IGalileoToken.transfer()] --> Retailer Wallet

Preconditions:
- Receiver (retailer) has AUTHORIZED_RETAILER claim
- Receiver country not in brand's restricted list
- Token not paused

Events:
- Transfer (ERC-20)
- TransferWithReason (if using extended transfer)

Result:
- Token balance: Brand 0, Retailer 1
- CPO status: Not applicable (new product)
```

Retailer to Consumer:
```
Retailer Wallet --> [IGalileoToken.transfer()] --> Consumer Wallet

Preconditions:
- Sender has AUTHORIZED_RETAILER claim
- Receiver has KYC_BASIC claim (or KYC_ENHANCED for high value)
- Receiver country not sanctioned

Events:
- Transfer (ERC-20)
- FirstSaleRecorded (lifecycle event)

Result:
- Token balance: Retailer 0, Consumer 1
- Warranty starts (if applicable)
```

**4. Secondary Sale (Resale) Flow**

Consumer to Consumer (with CPO):
```
Seller Wallet --> [IGalileoToken.transfer()] --> Buyer Wallet

Preconditions:
- Seller has KYC_BASIC claim
- Buyer has KYC_BASIC claim
- If CPO required: token.isCPOCertified() == true
- Buyer country not sanctioned

CPO Certification (if required):
1. Seller sends to authorized authenticator
2. Authenticator verifies and calls token.certifyCPO()
3. Authenticator returns to seller
4. Seller completes sale to buyer

Events:
- Transfer (ERC-20)
- CPOTransferred (if CPO maintained)

Result:
- Token balance: Seller 0, Buyer 1
- CPO status maintained (if was certified)
```

Auction House Sale:
```
Consignor Wallet --> [Transfer to Auction House] --> Winner Wallet

Preconditions:
- Consignor has KYC_BASIC claim
- Auction house has AUCTION_HOUSE claim
- Winner has KYC_BASIC claim (or KYC_ENHANCED for high value)
- CPO certification verified

Events:
- Transfer (consignor to auction house)
- Transfer (auction house to winner)
- AuctionSaleCompleted (custom event)
```

**5. MRO (Maintenance, Repair, Overhaul) Transfer**

Transfer to Service Center:
```
Owner Wallet --> [IGalileoToken.transfer()] --> Service Center Wallet

Preconditions:
- Owner has KYC_BASIC claim
- Service center has SERVICE_CENTER claim
- Service center authorized for service type

Note: This is a TEMPORARY transfer for service work.
The expectation is return to owner after service complete.

Events:
- Transfer (ERC-20)
- MROTransferInitiated

Result:
- Token balance: Owner 0, Service Center 1
- Service record created (off-chain)
```

Return from Service Center:
```
Service Center Wallet --> [IGalileoToken.transfer()] --> Owner Wallet

Preconditions:
- Service center has SERVICE_CENTER claim
- Owner identity verified (same identity as before transfer)
- Service complete flag set

Events:
- Transfer (ERC-20)
- MROTransferCompleted
- ServiceRecordAttached (off-chain link)

Result:
- Token balance: Service Center 0, Owner 1
- Service record linked to product DPP
```

**6. Recovery Flow**

Lost/Compromised Wallet Recovery:
```
Agent calls recoveryAddress(lostWallet, newWallet, investorOnchainID)

Preconditions:
- Agent has AgentRole in token contract
- Agent is multi-sig (2-of-3 minimum for production)
- Identity proof verified off-chain
- investorOnchainID matches lostWallet's identity

Process:
1. Owner contacts brand/issuer with identity proof
2. Off-chain verification (ID documents, knowledge questions)
3. Agent initiates recovery
4. Token balance transferred from lostWallet to newWallet
5. Identity registry updated (if needed)

Events:
- RecoveryInitiated
- RecoverySuccess

Result:
- Token balance: Lost Wallet 0, New Wallet 1
- Provenance chain maintained
```

**7. Forced Transfer**

Regulatory/Legal Required Transfer:
```
Agent calls forcedTransfer(from, to, amount, data)

Use Cases:
- Court-ordered asset seizure
- Regulatory action
- Fraud recovery

Preconditions:
- Agent has AgentRole with forcedTransfer permission
- Legal documentation attached in data parameter (hash)
- Compliance module allows forced transfers

Events:
- ForcedTransfer (ERC-3643)
- TransferWithReason (reasonCode = FORCED_LEGAL)

Result:
- Token transferred regardless of normal compliance
- Full audit trail preserved
```

**8. Batch Operations**

For high-volume operations (brand distributions, auctions):
```solidity
// Batch transfer from brand to multiple retailers
token.batchTransfer(
    [retailer1, retailer2, retailer3],
    [1, 1, 1]
);
```

Preconditions:
- All receivers must pass compliance checks
- Atomic execution (all succeed or all fail)

**9. Transfer Reason Codes**

Standard reason codes for audit trail:
| Code | Description |
|------|-------------|
| `0x01` | PRIMARY_SALE |
| `0x02` | SECONDARY_SALE |
| `0x03` | AUCTION_SALE |
| `0x04` | MRO_TRANSFER |
| `0x05` | MRO_RETURN |
| `0x06` | GIFT |
| `0x07` | INHERITANCE |
| `0x08` | FORCED_LEGAL |
| `0x09` | RECOVERY |
| `0x0A` | DECOMMISSION |

**10. Error Handling**

Standard error responses:
| Error | Condition |
|-------|-----------|
| `TokenPaused` | Global pause active |
| `SenderFrozen` | Sender address frozen |
| `ReceiverFrozen` | Receiver address frozen |
| `InsufficientUnfrozenBalance` | Partial freeze blocks transfer |
| `ReceiverNotVerified` | Receiver not in identity registry |
| `TransferNotCompliant` | Compliance module rejected |
| `CPORequired` | CPO certification required but missing |
| `JurisdictionBlocked` | Receiver country restricted |
| `SanctionedAddress` | Party on sanctions list |
  </action>
  <verify>Document exists with all transfer flows, compliance integration, and reason codes.</verify>
  <done>Ownership transfer specification covers all transfer scenarios with compliance integration.</done>
</task>

<task type="auto">
  <name>Task 3: Create IJurisdictionModule interface</name>
  <files>specifications/contracts/compliance/modules/IJurisdictionModule.sol</files>
  <action>
Create the Solidity interface for the jurisdiction restriction compliance module.

```solidity
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import "../IComplianceModule.sol";

/**
 * @title IJurisdictionModule
 * @notice Compliance module for country-based transfer restrictions
 * @dev Implements both allow and restrict modes for jurisdiction control.
 *      Uses ISO 3166-1 numeric country codes (uint16) from Identity Registry.
 *
 * Two operational modes:
 * - Allow Mode: Only specified countries can receive transfers
 * - Restrict Mode: Specified countries cannot receive transfers
 *
 * Country code is retrieved from the Identity Registry for each address.
 */
interface IJurisdictionModule is IComplianceModule {
    // ============ Enums ============

    /**
     * @notice Jurisdiction restriction mode
     */
    enum JurisdictionMode {
        ALLOW,      // Whitelist: only listed countries allowed
        RESTRICT    // Blacklist: listed countries blocked
    }

    // ============ View Functions ============

    /**
     * @notice Get the current jurisdiction mode
     * @return The active mode (ALLOW or RESTRICT)
     */
    function jurisdictionMode() external view returns (JurisdictionMode);

    /**
     * @notice Check if a country is in the country list
     * @param _country ISO 3166-1 numeric country code
     * @return True if country is in the list
     */
    function isCountryListed(uint16 _country) external view returns (bool);

    /**
     * @notice Check if a transfer to a country is allowed
     * @param _country ISO 3166-1 numeric country code
     * @return True if transfer to this country is allowed
     */
    function isCountryAllowed(uint16 _country) external view returns (bool);

    /**
     * @notice Get all countries in the list
     * @return Array of ISO 3166-1 country codes
     */
    function getCountryList() external view returns (uint16[] memory);

    /**
     * @notice Get country count in list
     * @return Number of countries in the list
     */
    function countryCount() external view returns (uint256);

    // ============ Configuration ============

    /**
     * @notice Set the jurisdiction mode
     * @param _mode The mode to set (ALLOW or RESTRICT)
     */
    function setJurisdictionMode(JurisdictionMode _mode) external;

    /**
     * @notice Add a country to the list
     * @param _country ISO 3166-1 numeric country code
     */
    function addCountry(uint16 _country) external;

    /**
     * @notice Remove a country from the list
     * @param _country ISO 3166-1 numeric country code
     */
    function removeCountry(uint16 _country) external;

    /**
     * @notice Batch add countries
     * @param _countries Array of ISO 3166-1 country codes
     */
    function addCountries(uint16[] calldata _countries) external;

    /**
     * @notice Batch remove countries
     * @param _countries Array of ISO 3166-1 country codes
     */
    function removeCountries(uint16[] calldata _countries) external;

    // ============ Country Group Management ============

    /**
     * @notice Add a predefined country group
     * @param _groupId The group identifier (e.g., keccak256("OFAC_SANCTIONED"))
     */
    function addCountryGroup(bytes32 _groupId) external;

    /**
     * @notice Remove a predefined country group
     * @param _groupId The group identifier
     */
    function removeCountryGroup(bytes32 _groupId) external;

    /**
     * @notice Check if a country group is active
     * @param _groupId The group identifier
     * @return True if the group is active
     */
    function isCountryGroupActive(bytes32 _groupId) external view returns (bool);

    // ============ Identity Registry Integration ============

    /**
     * @notice Set the identity registry for country lookups
     * @param _identityRegistry Address of the identity registry
     */
    function setIdentityRegistry(address _identityRegistry) external;

    /**
     * @notice Get the configured identity registry
     * @return Address of the identity registry
     */
    function identityRegistry() external view returns (address);

    /**
     * @notice Get country code for an address from identity registry
     * @param _address The address to lookup
     * @return Country code (0 if not found)
     */
    function getCountryOfAddress(address _address) external view returns (uint16);

    // ============ Events ============

    /**
     * @notice Emitted when jurisdiction mode changes
     */
    event JurisdictionModeChanged(JurisdictionMode oldMode, JurisdictionMode newMode);

    /**
     * @notice Emitted when country is added to list
     */
    event CountryAdded(uint16 indexed country);

    /**
     * @notice Emitted when country is removed from list
     */
    event CountryRemoved(uint16 indexed country);

    /**
     * @notice Emitted when country group is added
     */
    event CountryGroupAdded(bytes32 indexed groupId);

    /**
     * @notice Emitted when country group is removed
     */
    event CountryGroupRemoved(bytes32 indexed groupId);

    /**
     * @notice Emitted when transfer is blocked due to jurisdiction
     */
    event TransferBlockedJurisdiction(
        address indexed from,
        address indexed to,
        uint16 country
    );

    // ============ Errors ============

    /// @notice Thrown when country code is invalid (0 or > 999)
    error InvalidCountryCode(uint16 country);

    /// @notice Thrown when country is already in list
    error CountryAlreadyListed(uint16 country);

    /// @notice Thrown when country is not in list
    error CountryNotListed(uint16 country);

    /// @notice Thrown when receiver country is not allowed
    error CountryNotAllowed(uint16 country);

    /// @notice Thrown when identity registry returns no country
    error CountryNotFound(address account);
}

/**
 * @title CountryGroups
 * @notice Library of predefined country group identifiers
 */
library CountryGroups {
    /// @notice Countries under comprehensive OFAC sanctions
    bytes32 public constant OFAC_SANCTIONED = keccak256("OFAC_SANCTIONED");

    /// @notice Countries under EU sanctions
    bytes32 public constant EU_SANCTIONED = keccak256("EU_SANCTIONED");

    /// @notice FATF grey list countries
    bytes32 public constant FATF_GREYLIST = keccak256("FATF_GREYLIST");

    /// @notice OECD member countries
    bytes32 public constant OECD_MEMBERS = keccak256("OECD_MEMBERS");

    /// @notice European Union member states
    bytes32 public constant EU_MEMBERS = keccak256("EU_MEMBERS");

    /// @notice Developed APAC markets
    bytes32 public constant APAC_DEVELOPED = keccak256("APAC_DEVELOPED");
}
```

Include comprehensive NatSpec explaining:
- Allow vs Restrict modes
- ISO 3166-1 country code usage
- Integration with Identity Registry for country lookups
- Country group management
  </action>
  <verify>Interface exists with allow/restrict modes, country group library, and identity registry integration.</verify>
  <done>IJurisdictionModule enables country-based transfer restrictions.</done>
</task>

</tasks>

<verification>
All files exist and integrate correctly:

```bash
ls -la specifications/compliance/
ls -la specifications/token/
ls -la specifications/contracts/compliance/modules/
```

Check ownership transfer references compliance:
```bash
grep -r "canTransfer\|isVerified\|compliance" specifications/token/ownership-transfer.md
```

Check jurisdiction module references identity registry:
```bash
grep -r "identityRegistry\|investorCountry" specifications/contracts/compliance/modules/IJurisdictionModule.sol
```
</verification>

<success_criteria>
1. jurisdiction-rules.md specifies allow/restrict modes with ISO 3166-1 codes
2. jurisdiction-rules.md documents export control and sanctions list integration
3. ownership-transfer.md specifies complete transfer validation sequence
4. ownership-transfer.md covers primary sale, resale, MRO, and recovery flows
5. ownership-transfer.md integrates identity, compliance, and token interfaces
6. IJurisdictionModule.sol provides both allow and restrict modes
7. CountryGroups library defines standard country group identifiers
8. All files reference appropriate Phase 4 and Phase 5 interfaces
</success_criteria>

<output>
After completion, create `.planning/phases/05-token-compliance/05-04-SUMMARY.md`
</output>
