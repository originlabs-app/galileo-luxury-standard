---
phase: 05-token-compliance
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - specifications/compliance/kyc-hooks.md
  - specifications/compliance/aml-screening.md
  - specifications/contracts/compliance/modules/ISanctionsModule.sol
autonomous: true

must_haves:
  truths:
    - "KYC/KYB hooks integrate with Phase 4 identity infrastructure"
    - "AML screening specification enables Chainalysis oracle integration"
    - "Pre-transfer verification checks identity claims before any transfer"
    - "Sanctions module provides on-chain OFAC screening"
  artifacts:
    - path: "specifications/compliance/kyc-hooks.md"
      provides: "KYC/KYB verification hook specification"
      contains: "batchVerify"
      min_lines: 150
    - path: "specifications/compliance/aml-screening.md"
      provides: "AML/sanctions screening specification"
      contains: "Chainalysis"
      min_lines: 120
    - path: "specifications/contracts/compliance/modules/ISanctionsModule.sol"
      provides: "Chainalysis oracle integration interface"
      contains: "0x40C57923924B5c5c5455c48D93317139ADDaC8fb"
      min_lines: 60
  key_links:
    - from: "specifications/compliance/kyc-hooks.md"
      to: "specifications/contracts/identity/IIdentityRegistry.sol"
      via: "batchVerify integration"
      pattern: "IGalileoIdentityRegistry.batchVerify"
    - from: "specifications/contracts/compliance/modules/ISanctionsModule.sol"
      to: "Chainalysis Oracle"
      via: "SanctionsList interface"
      pattern: "SanctionsList\\(0x40C57923"
---

<objective>
Create KYC/KYB hook specifications and AML/sanctions screening module for pre-transfer compliance verification.

Purpose: Enable identity verification and sanctions screening before any token transfer, ensuring all parties meet regulatory requirements (MiCA, Travel Rule, OFAC).

Output: Specification documents for KYC/KYB hooks and AML screening, plus Solidity interface for Chainalysis oracle integration.
</objective>

<execution_context>
@/Users/pierrebeunardeau/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pierrebeunardeau/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-token-compliance/05-RESEARCH.md
@specifications/contracts/identity/IIdentityRegistry.sol
@specifications/contracts/identity/IClaimTopicsRegistry.sol
@.planning/phases/04-identity-infrastructure/04-01-SUMMARY.md
@.planning/phases/04-identity-infrastructure/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KYC/KYB hook specification</name>
  <files>specifications/compliance/kyc-hooks.md</files>
  <action>
Create a comprehensive specification document for KYC/KYB pre-transfer verification hooks.

Document structure:

**1. Overview**
- Purpose of KYC/KYB hooks in token transfers
- Integration with Phase 4 IGalileoIdentityRegistry
- Compliance drivers (MiCA, Travel Rule)

**2. Hook Architecture**
- Pre-transfer hook flow diagram (ASCII art):
  ```
  transfer() called
       |
       v
  [1. Check sender KYC]
       |
       v
  [2. Check receiver KYC]
       |
       v
  [3. Check transaction-specific claims]
       |
       v
  transfer() executes
  ```

**3. Claim Topic Requirements by Transfer Type**

Table of required claims per transfer scenario:
| Transfer Type | Sender Claims | Receiver Claims |
|---------------|---------------|-----------------|
| Primary Sale (brand to retailer) | - | AUTHORIZED_RETAILER |
| Primary Sale (retailer to consumer) | AUTHORIZED_RETAILER | KYC_BASIC |
| Secondary Sale (consumer to consumer) | KYC_BASIC | KYC_BASIC |
| High-Value Sale (>EUR 10,000) | KYC_ENHANCED | KYC_ENHANCED |
| B2B Transfer | KYB_VERIFIED | KYB_VERIFIED |
| MRO Transfer (to service center) | KYC_BASIC | SERVICE_CENTER |
| Auction House Sale | KYC_BASIC | AUCTION_HOUSE or KYC_BASIC |

**4. Integration with IGalileoIdentityRegistry**

Code examples using Phase 4 interfaces:
```solidity
// Single claim check
bool verified = identityRegistry.isVerified(receiver);

// Multi-claim check
uint256[] memory topics = new uint256[](2);
topics[0] = GalileoClaimTopics.KYC_BASIC;
topics[1] = GalileoClaimTopics.AUTHORIZED_RETAILER;
bool[] memory results = identityRegistry.batchVerify(receiver, topics);

// Cross-brand with consent
bool verified = identityRegistry.isVerifiedWithConsent(
    receiver,
    GalileoClaimTopics.KYC_BASIC,
    requestingBrand
);
```

**5. KYC Levels**

Define three KYC levels with requirements:
- Basic: ID verification + liveness (KYC_BASIC claim)
- Enhanced: Basic + proof of address + source of funds (KYC_ENHANCED claim)
- Business: Company verification + UBO (KYB_VERIFIED claim)

**6. Jurisdiction-Specific Requirements**

Table mapping jurisdictions to required claims:
- EU (MiFID): KYC_EU_MIFID
- US (SEC): KYC_US_SEC
- Singapore (MAS): KYC_APAC_SG

**7. Hook Interface Specification**

```solidity
interface IKYCComplianceHook {
    function requiredClaimTopics() external view returns (uint256[] memory);
    function verifySenderEligibility(address sender) external view returns (bool);
    function verifyReceiverEligibility(address receiver) external view returns (bool);
    function verifyTransferEligibility(address sender, address receiver)
        external view returns (bool senderOk, bool receiverOk);
}
```

**8. Error Handling**

Define error codes and messages:
- `SENDER_NOT_VERIFIED`: Sender lacks required KYC claims
- `RECEIVER_NOT_VERIFIED`: Receiver lacks required KYC claims
- `CLAIM_EXPIRED`: Required claim has expired
- `CLAIM_REVOKED`: Required claim has been revoked
- `CONSENT_NOT_GRANTED`: Cross-brand consent not provided

**9. Travel Rule Compliance**

Explain how KYC hooks support Travel Rule:
- Originator data from sender's ONCHAINID
- Beneficiary data from receiver's ONCHAINID
- Data fields required per TFR regulation
  </action>
  <verify>Document exists with all sections, references Phase 4 batchVerify, includes claim topic table.</verify>
  <done>KYC/KYB hook specification enables pre-transfer identity verification.</done>
</task>

<task type="auto">
  <name>Task 2: Create AML/sanctions screening specification</name>
  <files>specifications/compliance/aml-screening.md</files>
  <action>
Create a comprehensive specification document for AML and sanctions screening.

Document structure:

**1. Overview**
- Purpose of AML/sanctions screening in token transfers
- Regulatory drivers (OFAC, EU sanctions, MiCA)
- On-chain vs off-chain screening layers

**2. Sanctions Screening Architecture**

```
Pre-transfer Sanctions Check
           |
           v
   +-------+-------+
   |               |
   v               v
[On-chain:      [Off-chain:
 Chainalysis     TRM Labs/
 Oracle]         Elliptic API]
   |               |
   +-------+-------+
           |
           v
   [Aggregate Result]
```

**3. Chainalysis Oracle Integration**

- Oracle address: `0x40C57923924B5c5c5455c48D93317139ADDaC8fb`
- Interface:
  ```solidity
  interface SanctionsList {
      function isSanctioned(address addr) external view returns (bool);
  }
  ```
- Chain availability (same address on most EVM chains)
- Update latency considerations (can be 60+ days behind OFAC)

**4. Multi-Layer Screening Strategy**

| Layer | Provider | Check Type | Latency |
|-------|----------|------------|---------|
| 1 | Chainalysis Oracle | On-chain | Real-time |
| 2 | Off-chain API | Pre-transfer | Minutes |
| 3 | Daily batch | Existing holders | Daily |

**5. High-Value Transfer Protocol**

For transfers >EUR 10,000:
1. On-chain Chainalysis check (blocking)
2. Off-chain TRM Labs check (blocking)
3. Enhanced due diligence flag if new relationship

**6. AML Risk Scoring**

Risk score thresholds:
- Low (0-30): Automatic approval
- Medium (31-70): Enhanced monitoring
- High (71-100): Manual review required

**7. Sanctions Event Handling**

When sanctions check fails:
1. Transfer blocked with `SanctionedTransferBlocked` event
2. Addresses logged for compliance reporting
3. Optional: freeze flagged addresses via `setAddressFrozen()`

**8. Compliance Reporting**

Events emitted for compliance audit:
- `SanctionsCheckPerformed(address indexed subject, bool result, string provider)`
- `SanctionedAddressDetected(address indexed subject, string sanctionsList)`
- `HighValueTransferScreened(address indexed from, address indexed to, uint256 amount)`

**9. Integration with Compliance Module**

How ISanctionsModule integrates with IModularCompliance:
- moduleCheck() queries Chainalysis oracle
- Returns false if either party sanctioned
- Emits blocking event with details

**10. Limitations and Mitigations**

| Limitation | Mitigation |
|------------|------------|
| Oracle update latency | Layer with off-chain API |
| On-chain only checks addresses | Off-chain checks transaction patterns |
| No risk scoring on-chain | Off-chain risk scoring integration |
| Single oracle dependency | Support multiple oracle sources |
  </action>
  <verify>Document exists with Chainalysis address, multi-layer strategy, and MiCA references.</verify>
  <done>AML screening specification enables multi-layer sanctions compliance.</done>
</task>

<task type="auto">
  <name>Task 3: Create ISanctionsModule interface</name>
  <files>specifications/contracts/compliance/modules/ISanctionsModule.sol</files>
  <action>
Create the Solidity interface for the sanctions screening compliance module.

```solidity
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import "../IComplianceModule.sol";

/**
 * @title ISanctionsModule
 * @notice Compliance module for OFAC sanctions screening via Chainalysis oracle
 * @dev Integrates with the Chainalysis Sanctions Oracle deployed at the same
 *      address on most EVM chains: 0x40C57923924B5c5c5455c48D93317139ADDaC8fb
 *
 * Important: The Chainalysis oracle may have update latency of 60+ days.
 * For high-value transfers, layer with off-chain screening APIs.
 */
interface ISanctionsModule is IComplianceModule {
    // ============ Chainalysis Oracle Interface ============

    /**
     * @notice Get the address of the configured sanctions oracle
     * @return The oracle contract address
     */
    function sanctionsOracle() external view returns (address);

    /**
     * @notice Check if an address is sanctioned
     * @param _address The address to check
     * @return True if the address is on the sanctions list
     */
    function isSanctioned(address _address) external view returns (bool);

    /**
     * @notice Check if either party is sanctioned
     * @param _from Sender address
     * @param _to Receiver address
     * @return fromSanctioned True if sender is sanctioned
     * @return toSanctioned True if receiver is sanctioned
     */
    function checkBothParties(address _from, address _to)
        external view returns (bool fromSanctioned, bool toSanctioned);

    // ============ Configuration ============

    /**
     * @notice Set the sanctions oracle address
     * @dev For chain-specific deployments where oracle address differs
     * @param _oracle The oracle contract address
     */
    function setSanctionsOracle(address _oracle) external;

    /**
     * @notice Enable or disable strict mode
     * @dev In strict mode, any oracle failure reverts. In non-strict, oracle
     *      failures allow transfer (fail-open for availability).
     * @param _strict True for fail-closed, false for fail-open
     */
    function setStrictMode(bool _strict) external;

    /**
     * @notice Get strict mode status
     * @return True if strict mode (fail-closed) is enabled
     */
    function isStrictMode() external view returns (bool);

    // ============ High-Value Transfer Threshold ============

    /**
     * @notice Set threshold for enhanced screening
     * @dev Transfers above this threshold may require additional off-chain checks
     * @param _threshold Amount in token's smallest unit
     */
    function setHighValueThreshold(uint256 _threshold) external;

    /**
     * @notice Get high-value transfer threshold
     * @return The threshold amount
     */
    function highValueThreshold() external view returns (uint256);

    /**
     * @notice Check if a transfer is high-value
     * @param _amount The transfer amount
     * @return True if amount exceeds high-value threshold
     */
    function isHighValueTransfer(uint256 _amount) external view returns (bool);

    // ============ Events ============

    /**
     * @notice Emitted when a sanctioned transfer is blocked
     */
    event SanctionedTransferBlocked(
        address indexed from,
        address indexed to,
        uint256 amount,
        bool fromSanctioned,
        bool toSanctioned
    );

    /**
     * @notice Emitted when sanctions check is performed
     */
    event SanctionsCheckPerformed(
        address indexed subject,
        bool isSanctioned,
        uint256 timestamp
    );

    /**
     * @notice Emitted when a high-value transfer requires enhanced screening
     */
    event HighValueTransferFlagged(
        address indexed from,
        address indexed to,
        uint256 amount
    );

    /**
     * @notice Emitted when oracle address is updated
     */
    event SanctionsOracleUpdated(
        address indexed oldOracle,
        address indexed newOracle
    );

    // ============ Errors ============

    /// @notice Thrown when sender is on sanctions list
    error SenderSanctioned(address sender);

    /// @notice Thrown when receiver is on sanctions list
    error ReceiverSanctioned(address receiver);

    /// @notice Thrown when oracle call fails in strict mode
    error OracleCallFailed();

    /// @notice Thrown when setting zero address as oracle
    error InvalidOracleAddress();
}

/**
 * @title SanctionsList
 * @notice Interface for the Chainalysis sanctions oracle
 * @dev Deployed at 0x40C57923924B5c5c5455c48D93317139ADDaC8fb on most EVM chains
 */
interface SanctionsList {
    /**
     * @notice Check if an address is on the OFAC sanctions list
     * @param addr The address to check
     * @return True if the address is sanctioned
     */
    function isSanctioned(address addr) external view returns (bool);
}
```

Include comprehensive NatSpec explaining:
- Chainalysis oracle mechanics
- Update latency considerations
- Strict vs non-strict mode tradeoffs
- High-value transfer handling
  </action>
  <verify>Interface exists with Chainalysis oracle address constant and SanctionsList interface.</verify>
  <done>ISanctionsModule enables on-chain OFAC sanctions screening.</done>
</task>

</tasks>

<verification>
All files exist and reference correct integration points:

```bash
ls -la specifications/compliance/
ls -la specifications/contracts/compliance/modules/
```

Check KYC hooks reference Phase 4:
```bash
grep -r "batchVerify\|IGalileoIdentityRegistry" specifications/compliance/kyc-hooks.md
```

Check AML screening references Chainalysis:
```bash
grep -r "0x40C57923924B5c5c5455c48D93317139ADDaC8fb\|Chainalysis" specifications/compliance/
```
</verification>

<success_criteria>
1. kyc-hooks.md specifies KYC/KYB verification hooks with claim topic requirements
2. kyc-hooks.md integrates with IGalileoIdentityRegistry.batchVerify()
3. aml-screening.md specifies multi-layer sanctions screening strategy
4. aml-screening.md documents Chainalysis oracle integration with latency considerations
5. ISanctionsModule.sol provides Chainalysis integration interface
6. ISanctionsModule.sol includes SanctionsList interface with correct oracle address
7. All documents reference MiCA and Travel Rule compliance requirements
</success_criteria>

<output>
After completion, create `.planning/phases/05-token-compliance/05-03-SUMMARY.md`
</output>
