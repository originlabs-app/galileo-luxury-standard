---
phase: 07-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - specifications/infrastructure/rbac-framework.md
  - specifications/infrastructure/audit-trail.md
  - specifications/contracts/infrastructure/IAccessControl.sol
autonomous: true
user_setup: []

must_haves:
  truths:
    - "RBAC framework defines 5 roles (brand_admin, operator, auditor, regulator, service_center) with permission matrix"
    - "Two-tier access control combines off-chain JWT with on-chain ONCHAINID claim verification"
    - "Audit trail specification enables immutable hash-chain logging with Merkle tree anchoring"
    - "All privileged operations are logged with actor, action, resource, and outcome"
  artifacts:
    - path: "specifications/infrastructure/rbac-framework.md"
      provides: "Complete RBAC specification with roles, permissions, and verification flows"
      contains: "OpenZeppelin AccessControl"
    - path: "specifications/infrastructure/audit-trail.md"
      provides: "Immutable audit log specification with hash chain and Merkle anchoring"
      contains: "hash-chain"
    - path: "specifications/contracts/infrastructure/IAccessControl.sol"
      provides: "Solidity interface for RBAC with ONCHAINID integration"
      contains: "IGalileoAccessControl"
  key_links:
    - from: "specifications/infrastructure/rbac-framework.md"
      to: "specifications/identity/claim-topics.md"
      via: "Claim topic mapping for role verification"
      pattern: "SERVICE_CENTER"
    - from: "specifications/infrastructure/rbac-framework.md"
      to: "specifications/resolver/access-control.md"
      via: "JWT role claims alignment"
      pattern: "brand|regulator|service_center"
    - from: "specifications/contracts/infrastructure/IAccessControl.sol"
      to: "specifications/contracts/identity/IIdentityRegistry.sol"
      via: "ONCHAINID verification integration"
      pattern: "IGalileoIdentityRegistry"
---

<objective>
Create the RBAC framework specification and immutable audit trail specification for the Galileo ecosystem.

Purpose: Define the access control model that governs who can read/write which data, and establish an immutable audit trail for all privileged operations. These specifications ensure security, accountability, and regulatory compliance (GDPR, AML, MiCA).

Output:
- specifications/infrastructure/rbac-framework.md - Complete RBAC specification
- specifications/infrastructure/audit-trail.md - Immutable audit logging specification
- specifications/contracts/infrastructure/IAccessControl.sol - Extended AccessControl interface
</objective>

<execution_context>
@/Users/pierrebeunardeau/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pierrebeunardeau/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-infrastructure/07-RESEARCH.md
@specifications/resolver/access-control.md
@specifications/identity/claim-topics.md
@specifications/contracts/identity/IIdentityRegistry.sol
@specifications/architecture/HYBRID-ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: RBAC Framework Specification</name>
  <files>specifications/infrastructure/rbac-framework.md</files>
  <action>
Create comprehensive RBAC framework specification document with:

1. **Overview and Purpose**
   - Specification ID: GSPEC-INFRA-001
   - Two-tier access control model (off-chain JWT + on-chain claims)
   - Reference to OpenZeppelin AccessControl as implementation foundation
   - Integration with existing access-control.md (resolver layer)

2. **Role Definitions (5 roles)**

   | Role | Description | On-Chain Claim Required | JWT Role | Permission Scope |
   |------|-------------|------------------------|----------|------------------|
   | brand_admin | Brand administrator | KYB_VERIFIED | brand | Full access to own brand's products |
   | operator | Day-to-day operations | None | operator | Product lifecycle operations |
   | auditor | Internal/external audit | None | auditor | Read-only all data, audit logs |
   | regulator | Regulatory authority | None | regulator | Compliance data, audit trails |
   | service_center | Authorized repair | SERVICE_CENTER (0x1083...) | service_center | Service records for authorized brands |

3. **Permission Matrix by Resource Type**

   Create detailed permission matrix covering:
   - DPP (full and public views)
   - Ownership records
   - Service history
   - Audit trail
   - Compliance data
   - Customer PII

   Use R/W/RW/- notation (Read/Write/ReadWrite/NoAccess)

4. **Two-Tier Verification Flow**

   ```
   Request -> Layer 1 (Off-Chain JWT) -> [Privileged?]
                                              |
                        NO                   YES
                        |                     |
                   Consumer               Layer 2 (On-Chain)
                   Access                 ONCHAINID verification
   ```

   - Layer 1: JWT validation, role extraction, basic permission check
   - Layer 2: ONCHAINID claim verification for privileged roles (brand_admin, service_center)
   - Cache strategy: 5-minute TTL for on-chain verification results

5. **Role-to-Claim Topic Mapping**

   Map each role requiring on-chain verification to specific claim topics from claim-topics.md:
   - brand_admin -> KYB_VERIFIED (0x5a2b...)
   - service_center -> SERVICE_CENTER (0x1083...)

   Include topic ID computation (keccak256)

6. **Role Hierarchy and Inheritance**

   Define role hierarchy using OpenZeppelin pattern:
   - DEFAULT_ADMIN_ROLE (consortium TSC)
   - BRAND_ADMIN_ROLE (brand-specific)
   - OPERATOR_ROLE, AUDITOR_ROLE, REGULATOR_ROLE

   Define which roles can grant/revoke other roles

7. **Role Grant/Revocation Workflow**

   - Grant with identity verification (grantRoleWithIdentity)
   - Revocation with audit logging
   - Suspension mechanism for investigation
   - Two-step admin transfer (AccessControlDefaultAdminRules)

8. **Anti-Patterns to Avoid**

   - Role explosion (keep to 5-10 roles max)
   - Caching stale RBAC data (max 5-min TTL)
   - On-chain role storage for all users (only privileged actors)
   - Synchronous on-chain verification for every request

Format: Follow existing specification style (version header, table of contents, diagrams, examples).
Reference: 07-RESEARCH.md for standard stack and patterns.
  </action>
  <verify>
Verify the document:
- Contains all 5 role definitions with claim mappings
- Includes complete permission matrix by resource type
- Documents two-tier verification flow with diagram
- References claim-topics.md and access-control.md
- Includes anti-patterns section
  </verify>
  <done>
RBAC framework specification exists at specifications/infrastructure/rbac-framework.md with complete role definitions, permission matrix, verification flows, and integration with existing identity infrastructure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Audit Trail Specification</name>
  <files>specifications/infrastructure/audit-trail.md</files>
  <action>
Create comprehensive audit trail specification document with:

1. **Overview and Purpose**
   - Specification ID: GSPEC-INFRA-002
   - Immutable append-only log for all privileged operations
   - Hash-chain integrity with periodic Merkle tree anchoring
   - 7-year retention requirement (SOX/regulatory alignment)

2. **Audit Event Types**

   Define complete event taxonomy:

   **Access Control Events:**
   - ROLE_GRANTED, ROLE_REVOKED
   - PERMISSION_CHECKED, ACCESS_DENIED

   **Data Lifecycle Events:**
   - DATA_CREATED, DATA_READ, DATA_UPDATED, DATA_DELETED

   **CRAB Model Events:**
   - ENCRYPTION_KEY_CREATED, ENCRYPTION_KEY_DESTROYED, CONTENT_ORPHANED

   **Compliance Events:**
   - ERASURE_REQUESTED, ERASURE_COMPLETED, ERASURE_REFUSED
   - RETENTION_PERIOD_STARTED, RETENTION_PERIOD_EXPIRED

   **System Events:**
   - MERKLE_ANCHOR_CREATED, HASH_CHAIN_VERIFIED, RECONCILIATION_RUN

3. **Audit Log Entry Schema**

   Define complete schema per 07-RESEARCH.md:
   ```typescript
   interface AuditLogEntry {
     entryId: string;        // UUID v7 (time-ordered)
     sequenceNumber: bigint; // Monotonically increasing
     timestamp: Date;        // ISO 8601 UTC
     previousHash: string;   // SHA-256 of previous entry
     entryHash: string;      // SHA-256 of this entry
     eventType: AuditEventType;
     actor: ActorInfo;       // type, identifier, role, IP
     action: string;
     resource: ResourceInfo; // type, identifier, attributes
     outcome: 'success' | 'failure' | 'partial';
     metadata: Record<string, unknown>;
   }
   ```

4. **Hash Chain Protocol**

   - Hash computation: SHA-256 of canonicalized entry JSON (RFC 8785 JCS)
   - Chain linking: previousHash = hash of entry (n-1)
   - Genesis entry: previousHash = 0x0...0 (64 zeros)
   - Verification: Re-hash and compare, detect breaks

5. **Merkle Tree Anchoring**

   - Daily Merkle tree construction from audit entries
   - Root hash anchored on-chain (cost: ~50k gas)
   - Merkle proof generation for individual entry verification
   - Integration with Trillian-style append-only log infrastructure

   ```
   Daily Anchor Flow:
   1. Collect all entries since last anchor
   2. Build Merkle tree (leaves = entry hashes)
   3. Emit on-chain event: AuditAnchor(rootHash, treeSize, timestamp)
   4. Store anchor metadata off-chain (tree data, proofs)
   ```

6. **Storage Architecture**

   - Off-chain: PostgreSQL with append-only table (no UPDATE/DELETE)
   - On-chain: Hash anchors only (rootHash, treeSize)
   - Index: Hash -> entryId lookup for verification

   Define table schema with immutability constraints:
   ```sql
   CREATE TABLE audit_log (
     entry_id UUID PRIMARY KEY,
     sequence_number BIGINT UNIQUE NOT NULL,
     ...
   );

   -- Prevent modifications
   CREATE RULE no_update AS ON UPDATE TO audit_log DO INSTEAD NOTHING;
   CREATE RULE no_delete AS ON DELETE TO audit_log DO INSTEAD NOTHING;
   ```

7. **Retention and Archival**

   - Active retention: 7 years (regulatory requirement)
   - Archive format: Merkle tree snapshots with proofs
   - Expiry workflow: Archive, verify, then delete
   - Legal hold support: Prevent expiry during litigation

8. **Query and Verification APIs**

   Define API patterns for:
   - Query by actor, resource, time range, event type
   - Verify entry integrity (hash chain check)
   - Generate Merkle proof for entry
   - Verify entry against on-chain anchor

9. **Failure Handling**

   - Write failure: Retry with deduplication (idempotency key)
   - Hash chain break detection: Quarantine, investigate
   - Reconciliation job: Daily consistency check

Format: Follow existing specification style (version header, table of contents, diagrams, examples).
Reference: 07-RESEARCH.md for Trillian/Certificate Transparency patterns.
  </action>
  <verify>
Verify the document:
- Contains complete audit event type taxonomy
- Includes audit log entry schema with all fields
- Documents hash chain protocol with genesis entry
- Specifies Merkle tree anchoring flow
- Includes PostgreSQL schema with immutability constraints
- Documents 7-year retention policy
  </verify>
  <done>
Audit trail specification exists at specifications/infrastructure/audit-trail.md with complete event taxonomy, hash-chain protocol, Merkle anchoring, storage architecture, and retention policies.
  </done>
</task>

<task type="auto">
  <name>Task 3: IGalileoAccessControl Interface</name>
  <files>specifications/contracts/infrastructure/IAccessControl.sol</files>
  <action>
Create Solidity interface extending OpenZeppelin AccessControl with ONCHAINID integration:

1. **File Header**
   - SPDX-License-Identifier: Apache-2.0
   - pragma solidity ^0.8.20
   - Import OpenZeppelin AccessControlEnumerable
   - Reference existing IGalileoIdentityRegistry

2. **Interface Definition**

   ```solidity
   interface IGalileoAccessControl is IAccessControlEnumerable {
   ```

3. **Role Constants**

   Define role bytes32 constants with keccak256 computation:
   - BRAND_ADMIN_ROLE
   - OPERATOR_ROLE
   - AUDITOR_ROLE
   - REGULATOR_ROLE
   - SERVICE_CENTER_ADMIN_ROLE

   Include computation in comments: keccak256("BRAND_ADMIN_ROLE")

4. **Role Management Functions**

   ```solidity
   function grantRoleWithIdentity(
     bytes32 role,
     address account,
     address identityAddress,
     uint256 requiredClaimTopic
   ) external;

   function hasRoleWithIdentity(
     bytes32 role,
     address account
   ) external view returns (bool);

   function setRoleClaimRequirement(
     bytes32 role,
     uint256 claimTopic
   ) external;

   function getRoleClaimRequirement(
     bytes32 role
   ) external view returns (uint256);
   ```

5. **Identity Registry Integration**

   ```solidity
   function setIdentityRegistry(
     address identityRegistry
   ) external;

   function getIdentityRegistry() external view returns (address);
   ```

6. **Audit Events**

   ```solidity
   event RoleGrantedWithIdentity(
     bytes32 indexed role,
     address indexed account,
     address indexed identityAddress,
     uint256 claimTopic
   );

   event RoleVerificationFailed(
     bytes32 indexed role,
     address indexed account,
     string reason
   );

   event RoleClaimRequirementSet(
     bytes32 indexed role,
     uint256 indexed claimTopic
   );
   ```

7. **Errors**

   ```solidity
   error IdentityNotVerified(address account);
   error ClaimNotValid(address account, uint256 claimTopic);
   error IdentityRegistryNotSet();
   error InvalidRoleClaimRequirement(bytes32 role, uint256 claimTopic);
   ```

8. **NatSpec Documentation**

   Add comprehensive NatSpec for every function:
   - @notice: Human-readable description
   - @dev: Implementation notes, security considerations
   - @param: Parameter descriptions
   - @return: Return value descriptions
   - @custom:security-contact: security@galileoprotocol.io

Follow the style from IIdentityRegistry.sol (existing Phase 4 patterns).
  </action>
  <verify>
Verify the Solidity file:
```bash
# Check syntax
grep -q "interface IGalileoAccessControl" specifications/contracts/infrastructure/IAccessControl.sol && echo "Has interface definition"
grep -q "BRAND_ADMIN_ROLE" specifications/contracts/infrastructure/IAccessControl.sol && echo "Has role constants"
grep -q "grantRoleWithIdentity" specifications/contracts/infrastructure/IAccessControl.sol && echo "Has identity-aware grant"
grep -q "RoleGrantedWithIdentity" specifications/contracts/infrastructure/IAccessControl.sol && echo "Has audit events"
```
  </verify>
  <done>
Solidity interface exists at specifications/contracts/infrastructure/IAccessControl.sol with role constants, ONCHAINID-integrated role management, and comprehensive NatSpec documentation following Phase 4 patterns.
  </done>
</task>

</tasks>

<verification>
Phase 7 Plan 01 verification:

1. **RBAC Framework Completeness**
   - [ ] 5 roles defined with claim mappings
   - [ ] Permission matrix for all resource types
   - [ ] Two-tier verification flow documented
   - [ ] Role hierarchy and inheritance defined
   - [ ] Anti-patterns section included

2. **Audit Trail Completeness**
   - [ ] Event taxonomy with all event types
   - [ ] Hash chain protocol with genesis entry
   - [ ] Merkle tree anchoring flow documented
   - [ ] PostgreSQL schema with immutability constraints
   - [ ] 7-year retention policy specified

3. **Interface Validity**
   - [ ] Extends OpenZeppelin AccessControlEnumerable
   - [ ] Role constants with keccak256 computation
   - [ ] Identity-aware grant/verify functions
   - [ ] Comprehensive NatSpec documentation

4. **Cross-Reference Integrity**
   - [ ] RBAC references claim-topics.md
   - [ ] RBAC references access-control.md
   - [ ] Interface references IIdentityRegistry
   - [ ] Consistent role names across all files
</verification>

<success_criteria>
- RBAC framework specification complete with 5 roles and permission matrix
- Audit trail specification complete with hash-chain protocol and Merkle anchoring
- Solidity interface extends OpenZeppelin with ONCHAINID integration
- All documents cross-reference existing specifications consistently
- Ready to support INFRA-02 (RBAC) and INFRA-03 (Audit) requirements
</success_criteria>

<output>
After completion, create `.planning/phases/07-infrastructure/07-01-SUMMARY.md`
</output>
