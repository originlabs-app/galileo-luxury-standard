---
phase: 04-identity-infrastructure
plan: 04-03
title: ONCHAINID and Verifiable Credentials
wave: 2
depends_on: [04-01, 04-02]
estimated_files: 3
---

# Plan 04-03: ONCHAINID and Verifiable Credentials

## Summary

This plan delivers the specification documents for ONCHAINID usage within Galileo and W3C Verifiable Credentials integration for privacy-preserving off-chain claims. ONCHAINID (implementing ERC-734 for key management and ERC-735 for claims) provides the on-chain identity contract pattern for Galileo participants (brands, retailers, issuers, and individual participants). The W3C VC 2.0 specification defines how claim content is stored off-chain while only hashes and signatures are recorded on-chain, ensuring GDPR compliance (no PII on blockchain) while maintaining cryptographic verifiability. These specifications bridge the on-chain interfaces (from 04-01, 04-02) with the off-chain claim ecosystem.

## Requirements Covered

- **IDENT-05**: Specification ONCHAINID pour participants (marques, utilisateurs) - ERC-734/735 compliant identity contracts for Galileo ecosystem
- **IDENT-06**: Specification W3C Verifiable Credentials pour claims - Privacy-preserving off-chain claim issuance and verification

## Artifacts

### ONCHAINID Specification
- `specifications/identity/onchainid-specification.md` - Complete specification for ONCHAINID usage in Galileo: key management, claim lifecycle, consent mechanism, cross-chain considerations

### W3C Verifiable Credentials Specification
- `specifications/identity/verifiable-credentials.md` - W3C VC 2.0 integration specification: credential types, on-chain hash anchoring, BitstringStatusList revocation, off-chain storage patterns

### JSON Schema
- `specifications/schemas/identity/galileo-vc.schema.json` - JSON Schema for validating Galileo Verifiable Credentials

## Must-Haves

1. **onchainid-specification.md** defines key purposes: MANAGEMENT (1), ACTION (2), CLAIM (3), ENCRYPTION (4)
2. **onchainid-specification.md** specifies claim signature computation: `keccak256(abi.encode(identity, topic, data))`
3. **onchainid-specification.md** includes IGalileoIdentity interface with consent methods
4. **onchainid-specification.md** covers CREATE2 factory deployment for cross-chain address consistency
5. **verifiable-credentials.md** uses W3C VC Data Model 2.0 (May 2025 Recommendation)
6. **verifiable-credentials.md** specifies on-chain claim data encoding: `keccak256(vcContent) + vcURI`
7. **verifiable-credentials.md** integrates BitstringStatusList v1.0 for revocation/suspension
8. **verifiable-credentials.md** defines Galileo credential types: KYCCredential, LuxuryCredential
9. **galileo-vc.schema.json** validates all Galileo credential types
10. **All specifications** ensure no PII stored on-chain (EDPB 02/2025 compliance)

## Approach

### Task 1: ONCHAINID Specification

Create comprehensive ONCHAINID specification for Galileo participants:

**File:** `specifications/identity/onchainid-specification.md`

**Document Structure:**

```markdown
# ONCHAINID Specification for Galileo

## Overview

ONCHAINID is the identity contract standard for Galileo participants. Based on ERC-734 (key management) and ERC-735 (claims management), it provides:
- Persistent identity not tied to wallet addresses
- Key rotation without losing claims or history
- Cross-chain address determinism via CREATE2
- Consent-based claim sharing for GDPR compliance

## Key Management (ERC-734)

### Key Purposes

| Purpose | Value | Description | Who Holds |
|---------|-------|-------------|-----------|
| MANAGEMENT | 1 | Add/remove keys, recover identity | Owner, guardians |
| ACTION | 2 | Sign transactions, execute calls | Owner, delegates |
| CLAIM | 3 | Issue/revoke claims on this identity | Trusted issuers |
| ENCRYPTION | 4 | Encrypt data for this identity | Messaging services |

### Key Types

- `keccak256(abi.encodePacked(address))` for ECDSA keys
- Future: ML-DSA keys for post-quantum (Phase 2 crypto-agility)

### Key Lifecycle

1. **addKey(bytes32 _key, uint256 _purpose, uint256 _type)**
   - Requires MANAGEMENT key
   - Emits KeyAdded event

2. **removeKey(bytes32 _key, uint256 _purpose)**
   - Requires MANAGEMENT key
   - Cannot remove last MANAGEMENT key
   - Emits KeyRemoved event
   - Historical claims remain valid (key rotation does not invalidate)

3. **keyHasPurpose(bytes32 _key, uint256 _purpose) returns (bool)**
   - Pure read function
   - Used by verification contracts

## Claims Management (ERC-735)

### Claim Structure

```solidity
struct Claim {
    uint256 topic;      // keccak256 of namespace string
    uint256 scheme;     // 1=ECDSA, 2=RSA, 3=ML-DSA (future)
    address issuer;     // ClaimIssuer contract address
    bytes signature;    // Issuer signature
    bytes data;         // Encoded claim hash + URI (NOT raw content)
    string uri;         // Pointer to off-chain VC
}
```

### Claim Data Encoding

**Critical:** The `data` field contains encoded references, never raw PII:

```solidity
bytes claimData = abi.encode(
    keccak256(vcJsonString),  // keccak256 hash of canonical VC (RFC 8785 JCS)
    vcURI                      // "https://vc.galileo.luxury/credentials/{id}"
);
```

### Signature Computation

Issuer creates signature:
```solidity
bytes32 digest = keccak256(abi.encode(
    identityAddress,    // ONCHAINID contract address
    claimTopic,         // uint256 topic ID
    claimData           // bytes encoded hash + URI
));
bytes memory signature = sign(digest, issuerPrivateKey);
```

### Claim Lifecycle

1. **addClaim(uint256 _topic, uint256 _scheme, address _issuer, bytes _signature, bytes _data, string _uri)**
   - Callable by MANAGEMENT key or issuer with CLAIM purpose
   - Verifies issuer is in TrustedIssuersRegistry
   - Verifies issuer is authorized for topic
   - Emits ClaimAdded event

2. **removeClaim(bytes32 _claimId)**
   - Callable by MANAGEMENT key or original issuer
   - Emits ClaimRemoved event
   - On-chain removal triggers off-chain BitstringStatusList update

3. **getClaim(bytes32 _claimId) returns (Claim)**
4. **getClaimIdsByTopic(uint256 _topic) returns (bytes32[])**

## Galileo Identity Extension

### IGalileoIdentity Interface

```solidity
interface IGalileoIdentity is IIdentity {
    // === Consent Management ===

    event ConsentGranted(address indexed brand, uint256 indexed topic, uint256 expiry);
    event ConsentRevoked(address indexed brand, uint256 indexed topic);

    function hasConsent(address brand, uint256 topic) external view returns (bool);
    function grantConsent(address brand, uint256 topic, uint256 expiry) external;
    function revokeConsent(address brand, uint256 topic) external;
    function getConsents() external view returns (Consent[] memory);

    // === Participant Type ===

    /// @dev Service-center/authenticator roles are conveyed via claim topics; participant type stays generic.
    enum ParticipantType { INDIVIDUAL, BRAND, RETAILER, ISSUER, VERIFIER }

    function getParticipantType() external view returns (ParticipantType);
    function setParticipantType(ParticipantType _type) external;
}
```

### Consent Structure

```solidity
struct Consent {
    address brand;      // Brand's Identity Registry address
    uint256 topic;      // Claim topic consent applies to
    uint256 grantedAt;  // Timestamp of grant
    uint256 expiresAt;  // 0 = no expiry
}
```

## Factory Deployment

### CREATE2 for Cross-Chain Consistency

```solidity
address identity = IdFactory.createIdentity(
    owner,              // Initial MANAGEMENT key holder
    salt                // Deterministic salt (e.g., keccak256(userDID))
);
// Same salt + same factory address = same identity address on any chain
```

### Factory Requirements

- IdFactory deployed at same address on all supported chains
- Same deployer account used across chains
- Salt derivation from user DID ensures consistency

## Participant Types

| Type | Key Configuration | Typical Claims |
|------|-------------------|----------------|
| INDIVIDUAL | Owner MANAGEMENT, optional guardian | KYC_BASIC, KYC_ENHANCED |
| BRAND | Multi-sig MANAGEMENT, separate ACTION | KYB_VERIFIED, BRAND_ISSUER (meta) |
| RETAILER | Brand-delegated ACTION | AUTHORIZED_RETAILER |
| ISSUER | Lab/KYC MANAGEMENT | AUTHENTICATOR, KYC_BASIC |
| VERIFIER | Regulator or audit body | REGULATORY_BODY (meta) |

## Recovery (v2 Scope)

Social recovery via guardian keys deferred to v2 (AA-04 requirement).
Current specification: Single MANAGEMENT key with secure backup.
```

### Task 2: W3C Verifiable Credentials Specification

Create W3C VC integration specification:

**File:** `specifications/identity/verifiable-credentials.md`

**Document Structure:**

```markdown
# W3C Verifiable Credentials Specification for Galileo

## Overview

Galileo uses W3C Verifiable Credentials Data Model 2.0 for off-chain claim storage. Only cryptographic hashes are stored on-chain (in ONCHAINID claim `data` field), preserving privacy while enabling verification. This architecture ensures GDPR compliance (no PII on blockchain) while maintaining the integrity guarantees of blockchain verification.

## W3C VC 2.0 Alignment

Based on W3C Recommendation (May 2025):
- https://www.w3.org/TR/vc-data-model-2.0/

### Required @context

```json
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://vocab.galileo.luxury/contexts/galileo.jsonld"
  ]
}
```

## Galileo Credential Types

### GalileoKYCCredential

For compliance claims (KYC/KYB):

```json
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://vocab.galileo.luxury/contexts/galileo.jsonld"
  ],
  "type": ["VerifiableCredential", "GalileoKYCCredential"],
  "issuer": {
    "id": "did:galileo:issuer:onfido",
    "name": "Onfido KYC Services"
  },
  "validFrom": "2026-01-31T00:00:00Z",
  "validUntil": "2027-01-31T00:00:00Z",
  "credentialSubject": {
    "id": "did:galileo:artisan:anon-abc123",
    "galileo:kycLevel": "enhanced",
    "galileo:jurisdiction": "EU",
    "galileo:verificationDate": "2026-01-30",
    "galileo:verificationMethod": "document_and_biometric"
  },
  "credentialStatus": {
    "id": "https://status.galileo.luxury/credentials/1#94567",
    "type": "BitstringStatusListEntry",
    "statusPurpose": "revocation",
    "statusListIndex": "94567",
    "statusListCredential": "https://status.galileo.luxury/credentials/1"
  },
  "proof": {
    "type": "DataIntegrityProof",
    "cryptosuite": "eddsa-rdfc-2022",
    "verificationMethod": "did:galileo:issuer:onfido#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "z..."
  }
}
```

**Note:** Individual subject DIDs follow `specifications/identity/DID-METHOD.md`. Until a dedicated customer type is added, individual participants use the existing `did:galileo:artisan:*` entity type.

### GalileoLuxuryCredential

For luxury-specific claims (retailer, service, authenticator):

```json
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://vocab.galileo.luxury/contexts/galileo.jsonld"
  ],
  "type": ["VerifiableCredential", "GalileoLuxuryCredential"],
  "issuer": {
    "id": "did:galileo:brand:hermes",
    "name": "Hermes International"
  },
  "validFrom": "2026-01-01T00:00:00Z",
  "validUntil": "2027-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:galileo:retailer:24sevres",
    "galileo:credentialType": "authorized_retailer",
    "galileo:brandAuthorization": "did:galileo:brand:hermes",
    "galileo:territory": ["FR", "BE", "LU"],
    "galileo:categories": ["leather_goods", "ready_to_wear", "accessories"],
    "galileo:authorizedSince": "2018-03-15"
  },
  "credentialStatus": {
    "id": "https://status.galileo.luxury/credentials/2#12345",
    "type": "BitstringStatusListEntry",
    "statusPurpose": "revocation",
    "statusListIndex": "12345",
    "statusListCredential": "https://status.galileo.luxury/credentials/2"
  },
  "proof": {
    "type": "DataIntegrityProof",
    "cryptosuite": "eddsa-rdfc-2022",
    "verificationMethod": "did:galileo:brand:hermes#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "z..."
  }
}
```

### GalileoHeritageCredential

For permanent heritage claims (origin, authenticity):

```json
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://vocab.galileo.luxury/contexts/galileo.jsonld"
  ],
  "type": ["VerifiableCredential", "GalileoHeritageCredential"],
  "issuer": {
    "id": "did:galileo:issuer:entrupy",
    "name": "Entrupy Authentication"
  },
  "validFrom": "2026-01-31T00:00:00Z",
  "credentialSubject": {
    "id": "did:galileo:01:03426795123456:21:ABC123",
    "galileo:credentialType": "authenticity_verified",
    "galileo:verificationDate": "2026-01-31",
    "galileo:methodology": "microscopic_analysis",
    "galileo:confidence": 0.9987,
    "galileo:reportURI": "https://reports.entrupy.com/verify/abc123"
  },
  "credentialStatus": {
    "id": "https://status.galileo.luxury/credentials/3#67890",
    "type": "BitstringStatusListEntry",
    "statusPurpose": "revocation",
    "statusListIndex": "67890",
    "statusListCredential": "https://status.galileo.luxury/credentials/3"
  },
  "proof": {
    "type": "DataIntegrityProof",
    "cryptosuite": "eddsa-rdfc-2022",
    "verificationMethod": "did:galileo:issuer:entrupy#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "z..."
  }
}
```

## On-Chain Hash Anchoring

### Claim Data Encoding

The ONCHAINID claim `data` field contains:

```solidity
bytes claimData = abi.encode(
    keccak256(canonicalVCJson),  // Content hash
    vcURI                         // Retrieval URI
);
```

### Canonicalization

Before hashing, VC JSON must be canonicalized:
1. Sort object keys alphabetically
2. Remove whitespace
3. Use RFC 8785 JSON Canonicalization Scheme (JCS)

```javascript
const canonical = JSON.stringify(vc, Object.keys(vc).sort());
const contentHash = keccak256(canonical);
```

### Verification Flow

1. Retrieve claim from ONCHAINID: `getClaim(claimId)`
2. Decode claim data: `(contentHash, vcURI) = abi.decode(claim.data)`
3. Fetch VC from vcURI
4. Canonicalize fetched VC
5. Verify: `keccak256(canonical) == contentHash`
6. Verify signature on VC proof
7. Check BitstringStatusList for revocation
8. Check temporal validity (validFrom, validUntil)

## BitstringStatusList Integration

### Status Credential

```json
{
  "@context": ["https://www.w3.org/ns/credentials/v2"],
  "id": "https://status.galileo.luxury/credentials/1",
  "type": ["VerifiableCredential", "BitstringStatusListCredential"],
  "issuer": "did:galileo:consortium",
  "validFrom": "2026-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "https://status.galileo.luxury/credentials/1#list",
    "type": "BitstringStatusList",
    "statusPurpose": "revocation",
    "encodedList": "H4sIAAAAAAAAA-3BMQEAAADCoPVPbQwfo..."
  }
}
```

### Status Purposes

| Purpose | Use Case | Reversible |
|---------|----------|------------|
| revocation | Permanent invalidity | No |
| suspension | Temporary invalidity | Yes |

### Galileo Status Lists

- `/credentials/1` - KYC/Compliance credentials (revocation + suspension)
- `/credentials/2` - Luxury authorization credentials (revocation + suspension)
- `/credentials/3` - Heritage credentials (revocation only)

### Caching

- Compliance credentials: TTL 5 minutes (short)
- Heritage credentials: TTL 24 hours (long)

## Off-Chain Storage

### Storage Requirements

- **Availability:** 99.9% uptime for VC retrieval
- **Integrity:** Hash verification on every retrieval
- **Privacy:** Access control based on consent
- **Retention:** 10+ years for heritage claims

### Recommended Architecture

```
                     +-------------------+
                     |   VC Gateway      |
                     |  (access control) |
                     +-------------------+
                            |
              +-------------+-------------+
              |                           |
     +--------v--------+       +----------v--------+
     |  Brand Storage  |       | Consortium IPFS   |
     | (private claims)|       | (public metadata) |
     +-----------------+       +-------------------+
```

### Access Control

Consent-based access per ONCHAINID consent mechanism:
1. Verifier requests VC from gateway
2. Gateway checks ONCHAINID.hasConsent(verifier, topic)
3. If consent valid, return VC
4. If no consent, return 403

## Proof Types

### Recommended: DataIntegrityProof

```json
{
  "type": "DataIntegrityProof",
  "cryptosuite": "eddsa-rdfc-2022",
  "verificationMethod": "did:galileo:issuer:xyz#key-1",
  "proofPurpose": "assertionMethod",
  "proofValue": "z..."
}
```

### Future: Post-Quantum Proofs

Per Phase 2 crypto-agility specification:
- 2027-2029: Hybrid proofs (classical + PQC)
- 2030+: ML-DSA proofs acceptable alone
```

### Task 3: Galileo VC JSON Schema

Create JSON Schema for validating Galileo VCs:

**File:** `specifications/schemas/identity/galileo-vc.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://schemas.galileo.luxury/credentials/v1/galileo-vc.schema.json",
  "title": "Galileo Verifiable Credential",
  "description": "JSON Schema for validating Galileo Verifiable Credentials",

  "definitions": {
    "vcBase": {
      "type": "object",
      "required": ["@context", "type", "issuer", "validFrom", "credentialSubject", "proof"],
      "properties": {
        "@context": {
          "type": "array",
          "items": { "type": "string" },
          "allOf": [
            { "contains": { "const": "https://www.w3.org/ns/credentials/v2" } },
            { "contains": { "const": "https://vocab.galileo.luxury/contexts/galileo.jsonld" } }
          ]
        },
        "type": {
          "type": "array",
          "items": { "type": "string" },
          "contains": { "const": "VerifiableCredential" }
        },
        "issuer": {
          "oneOf": [
            { "type": "string", "pattern": "^did:galileo:" },
            {
              "type": "object",
              "required": ["id"],
              "properties": {
                "id": { "type": "string", "pattern": "^did:galileo:" },
                "name": { "type": "string" }
              }
            }
          ]
        },
        "validFrom": { "type": "string", "format": "date-time" },
        "validUntil": { "type": "string", "format": "date-time" },
        "credentialSubject": { "type": "object" },
        "credentialStatus": { "$ref": "#/definitions/bitstringStatusEntry" },
        "proof": { "$ref": "#/definitions/dataIntegrityProof" }
      }
    },

    "bitstringStatusEntry": {
      "type": "object",
      "required": ["id", "type", "statusPurpose", "statusListIndex", "statusListCredential"],
      "properties": {
        "id": { "type": "string", "format": "uri" },
        "type": { "const": "BitstringStatusListEntry" },
        "statusPurpose": { "enum": ["revocation", "suspension"] },
        "statusListIndex": { "type": "string", "pattern": "^[0-9]+$" },
        "statusListCredential": { "type": "string", "format": "uri" }
      }
    },

    "dataIntegrityProof": {
      "type": "object",
      "required": ["type", "cryptosuite", "verificationMethod", "proofPurpose", "proofValue"],
      "properties": {
        "type": { "const": "DataIntegrityProof" },
        "cryptosuite": { "enum": ["eddsa-rdfc-2022", "ecdsa-rdfc-2019"] },
        "verificationMethod": { "type": "string" },
        "proofPurpose": { "const": "assertionMethod" },
        "proofValue": { "type": "string", "pattern": "^z[1-9A-HJ-NP-Za-km-z]+$" }
      }
    },

    "kycCredentialSubject": {
      "type": "object",
      "required": ["id", "galileo:kycLevel", "galileo:jurisdiction"],
      "properties": {
        "id": { "type": "string", "pattern": "^did:galileo:" },
        "galileo:kycLevel": { "enum": ["basic", "enhanced"] },
        "galileo:jurisdiction": { "type": "string", "pattern": "^[A-Z]{2}$" },
        "galileo:verificationDate": { "type": "string", "format": "date" },
        "galileo:verificationMethod": { "type": "string" }
      }
    },

    "luxuryCredentialSubject": {
      "type": "object",
      "required": ["id", "galileo:credentialType", "galileo:brandAuthorization"],
      "properties": {
        "id": { "type": "string", "pattern": "^did:galileo:" },
        "galileo:credentialType": {
          "enum": ["authorized_retailer", "service_center", "authenticator", "auction_house"]
        },
        "galileo:brandAuthorization": { "type": "string", "pattern": "^did:galileo:brand:" },
        "galileo:territory": {
          "type": "array",
          "items": { "type": "string", "pattern": "^[A-Z]{2}$" }
        },
        "galileo:categories": { "type": "array", "items": { "type": "string" } },
        "galileo:authorizedSince": { "type": "string", "format": "date" }
      }
    },

    "heritageCredentialSubject": {
      "type": "object",
      "required": ["id", "galileo:credentialType", "galileo:verificationDate"],
      "properties": {
        "id": { "type": "string", "pattern": "^did:galileo:" },
        "galileo:credentialType": {
          "enum": ["origin_certified", "authenticity_verified", "provenance_documented"]
        },
        "galileo:verificationDate": { "type": "string", "format": "date" },
        "galileo:methodology": { "type": "string" },
        "galileo:confidence": { "type": "number", "minimum": 0, "maximum": 1 },
        "galileo:reportURI": { "type": "string", "format": "uri" }
      }
    }
  },

  "oneOf": [
    {
      "allOf": [
        { "$ref": "#/definitions/vcBase" },
        {
          "properties": {
            "type": { "contains": { "const": "GalileoKYCCredential" } },
            "credentialSubject": { "$ref": "#/definitions/kycCredentialSubject" }
          }
        }
      ]
    },
    {
      "allOf": [
        { "$ref": "#/definitions/vcBase" },
        {
          "properties": {
            "type": { "contains": { "const": "GalileoLuxuryCredential" } },
            "credentialSubject": { "$ref": "#/definitions/luxuryCredentialSubject" }
          }
        }
      ]
    },
    {
      "allOf": [
        { "$ref": "#/definitions/vcBase" },
        {
          "properties": {
            "type": { "contains": { "const": "GalileoHeritageCredential" } },
            "credentialSubject": { "$ref": "#/definitions/heritageCredentialSubject" }
          }
        }
      ]
    }
  ]
}
```

## Dependencies

### External Standards
- **W3C VC Data Model 2.0**: https://www.w3.org/TR/vc-data-model-2.0/ (May 2025 Recommendation)
- **W3C Bitstring Status List v1.0**: https://www.w3.org/TR/vc-bitstring-status-list/
- **ONCHAINID**: ERC-734 (key management) + ERC-735 (claims management)
- **RFC 8785**: JSON Canonicalization Scheme for hash computation
- **JSON Schema 2020-12**: Schema validation standard

### Prior Phase Outputs
- **Phase 2 (02-01-PLAN)**: Hybrid architecture - no PII on-chain principle
- **Phase 2 (02-02-PLAN)**: Crypto-agility - future PQC proof support
- **Phase 2 (02-03-PLAN)**: did:galileo method - DID format for all entities

### Phase 4 Inputs
- **04-01-PLAN**: Identity Registry interfaces (IGalileoIdentityRegistry)
- **04-02-PLAN**: Trusted Issuers Registry, Claim Topics Registry interfaces
- **04-02-PLAN**: Predefined claim topics (namespace -> topicId mapping)

### Phase 4 Context
- **04-CONTEXT.md**: Hash-only on-chain (EDPB 02/2025 compliance)
- **04-CONTEXT.md**: Pseudonymous DID with optional KYC
- **04-CONTEXT.md**: Explicit consent for cross-brand sharing
- **04-RESEARCH.md**: Claim signature computation pattern
- **04-RESEARCH.md**: BitstringStatusList TTL recommendations

## Out of Scope

- Identity Registry implementation (interfaces in 04-01)
- Trusted Issuers Registry implementation (interface in 04-02)
- Claim Topics Registry implementation (interface in 04-02)
- VC storage infrastructure (operational concern)
- VC gateway implementation (operational concern)
- Social recovery mechanism (deferred to v2, AA-04)
- BBS+ selective disclosure (deferred to v2)
- Passkey authentication (deferred to v2, AA-05)
