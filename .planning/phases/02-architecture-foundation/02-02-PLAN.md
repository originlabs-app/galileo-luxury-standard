---
phase: 02-architecture-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - specifications/crypto/CRYPTO-AGILITY.md
autonomous: true

must_haves:
  truths:
    - "Cryptographic algorithms are abstracted behind interfaces, not hardcoded"
    - "Migration path from ECDSA to ML-DSA (NIST FIPS 204) is defined"
    - "Hybrid signature period (2027-2030) uses both classical and PQC signatures"
    - "Algorithm registry pattern enables runtime algorithm selection"
  artifacts:
    - path: "specifications/crypto/CRYPTO-AGILITY.md"
      provides: "Crypto-agile specification"
      contains: "ISignatureVerifier"
    - path: "specifications/crypto/CRYPTO-AGILITY.md"
      provides: "Migration roadmap"
      contains: "ML-DSA-65"
    - path: "specifications/crypto/CRYPTO-AGILITY.md"
      provides: "Hybrid signature format"
      contains: "dual-signature"
  key_links:
    - from: "specifications/crypto/CRYPTO-AGILITY.md"
      to: "NIST FIPS 203/204/205"
      via: "standard reference"
      pattern: "FIPS 20[345]|ML-DSA|ML-KEM"
    - from: "specifications/crypto/CRYPTO-AGILITY.md"
      to: "ERC-4337"
      via: "custom signature support"
      pattern: "ERC-4337|account abstraction"
---

<objective>
Create the crypto-agile specification for post-quantum cryptography readiness.

Purpose: Define abstract interfaces and migration patterns that enable the Galileo Luxury Standard to transition from current ECDSA to NIST-standardized post-quantum algorithms (ML-DSA, ML-KEM) without breaking changes. This addresses FOUND-06 and the 10-year timeline reality of luxury products.

Output: `specifications/crypto/CRYPTO-AGILITY.md` containing algorithm abstraction interfaces, migration roadmap, and hybrid signature specifications.
</objective>

<execution_context>
@/Users/pierrebeunardeau/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pierrebeunardeau/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-architecture-foundation/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Algorithm Abstraction Interfaces</name>
  <files>specifications/crypto/CRYPTO-AGILITY.md</files>
  <action>
Create `specifications/crypto/` directory.

Create `specifications/crypto/CRYPTO-AGILITY.md` with the following sections:

## 1. Overview

### 1.1 Purpose
- Enable signature scheme migration without breaking deployed contracts
- Prepare for post-quantum cryptography (NIST timeline: 2030 recommended full transition)
- Support hybrid signatures during transition period (2027-2030)
- Luxury product lifecycle (10+ years) requires crypto-agility from day one

### 1.2 Standards Referenced
- NIST FIPS 203: ML-KEM (Module-Lattice-Based Key Encapsulation Mechanism) - August 2024
- NIST FIPS 204: ML-DSA (Module-Lattice-Based Digital Signature Algorithm) - August 2024
- NIST FIPS 205: SLH-DSA (Stateless Hash-Based Digital Signature Algorithm) - August 2024
- ERC-4337: Account Abstraction for custom signature schemes

### 1.3 Design Principles
- **Never hardcode algorithms**: All crypto operations go through interfaces
- **Configuration over code**: Algorithm selection via registry, not conditionals
- **Graceful degradation**: If PQC unavailable, fall back to classical
- **Fail-secure**: Unknown algorithm ID rejects signature, doesn't accept

## 2. Algorithm Abstraction Interfaces

### 2.1 Signature Verification Interface

```typescript
/**
 * Abstract interface for signature verification.
 * Implementations exist for each supported algorithm family.
 */
interface ISignatureVerifier {
  /**
   * Verify a signature against a message hash.
   * @param hash - The message hash (always 32 bytes for interop)
   * @param signature - The signature bytes (format varies by algorithm)
   * @param publicKey - The public key bytes (format varies by algorithm)
   * @returns true if signature is valid, false otherwise
   */
  verify(hash: bytes32, signature: bytes, publicKey: bytes): boolean;

  /**
   * Return the algorithm identifier for this verifier.
   * Must match registry key exactly.
   */
  algorithmId(): string;

  /**
   * Return expected signature length in bytes.
   * Used for format validation before verification.
   */
  signatureLength(): uint256;

  /**
   * Return expected public key length in bytes.
   */
  publicKeyLength(): uint256;
}
```

### 2.2 Key Encapsulation Interface

```typescript
/**
 * Abstract interface for key encapsulation (key exchange).
 * Used for encrypted off-chain communication.
 */
interface IKeyEncapsulation {
  /**
   * Encapsulate a shared secret using recipient's public key.
   * @param publicKey - Recipient's public key
   * @returns ciphertext (to send) and sharedSecret (to use for encryption)
   */
  encapsulate(publicKey: bytes): { ciphertext: bytes, sharedSecret: bytes32 };

  /**
   * Decapsulate to recover shared secret using private key.
   * @param ciphertext - The encapsulated ciphertext
   * @param privateKey - Recipient's private key
   * @returns The shared secret (32 bytes)
   */
  decapsulate(ciphertext: bytes, privateKey: bytes): bytes32;

  /**
   * Return the algorithm identifier.
   */
  algorithmId(): string;

  /**
   * Return expected ciphertext length.
   */
  ciphertextLength(): uint256;
}
```

### 2.3 Crypto Registry Interface

```typescript
/**
 * Central registry for algorithm implementations.
 * Enables runtime algorithm selection without code changes.
 */
interface ICryptoRegistry {
  /**
   * Get verifier for a given algorithm ID.
   * @throws if algorithm not supported
   */
  getVerifier(algorithmId: string): ISignatureVerifier;

  /**
   * Get KEM for a given algorithm ID.
   * @throws if algorithm not supported
   */
  getKEM(algorithmId: string): IKeyEncapsulation;

  /**
   * Check if algorithm is supported.
   */
  isSupported(algorithmId: string): boolean;

  /**
   * List all supported algorithm IDs.
   */
  supportedAlgorithms(): string[];

  /**
   * Get the current default algorithm for new signatures.
   * Changes over time as migration progresses.
   */
  defaultSignatureAlgorithm(): string;

  /**
   * Get the current default algorithm for new key encapsulation.
   */
  defaultKEMAlgorithm(): string;
}
```

## 3. Algorithm Identifiers

Define canonical algorithm identifiers used throughout the system:

### 3.1 Signature Algorithms

| Algorithm ID | Standard | Status | Key Size | Sig Size |
|--------------|----------|--------|----------|----------|
| `ECDSA-secp256k1` | SEC 2 | Current default | 33 bytes | 65 bytes |
| `ECDSA-P256` | NIST | Supported | 33 bytes | 64 bytes |
| `Ed25519` | RFC 8032 | Supported | 32 bytes | 64 bytes |
| `ML-DSA-44` | FIPS 204 | Future (2027+) | 1312 bytes | 2420 bytes |
| `ML-DSA-65` | FIPS 204 | Future (2027+) | 1952 bytes | 3309 bytes |
| `ML-DSA-87` | FIPS 204 | Future (2027+) | 2592 bytes | 4627 bytes |
| `SLH-DSA-128s` | FIPS 205 | Backup option | 32 bytes | 7856 bytes |

### 3.2 Key Encapsulation Algorithms

| Algorithm ID | Standard | Status | Ciphertext | Shared Secret |
|--------------|----------|--------|------------|---------------|
| `ECDH-X25519` | RFC 7748 | Current default | 32 bytes | 32 bytes |
| `ECDH-P256` | NIST | Supported | 65 bytes | 32 bytes |
| `ML-KEM-512` | FIPS 203 | Future (2027+) | 768 bytes | 32 bytes |
| `ML-KEM-768` | FIPS 203 | Future (2027+) | 1088 bytes | 32 bytes |
| `ML-KEM-1024` | FIPS 203 | Future (2027+) | 1568 bytes | 32 bytes |

### 3.3 Recommended Security Levels

| Use Case | Current | Transition | Target |
|----------|---------|------------|--------|
| Standard products | ECDSA-secp256k1 | Hybrid | ML-DSA-65 |
| High-value items | Ed25519 | Hybrid | ML-DSA-87 |
| Off-chain encryption | ECDH-X25519 | Hybrid | ML-KEM-768 |
  </action>
  <verify>
File exists at `specifications/crypto/CRYPTO-AGILITY.md`.
File contains `ISignatureVerifier` interface.
File contains `IKeyEncapsulation` interface.
File contains `ICryptoRegistry` interface.
File contains algorithm identifier tables with ML-DSA and ML-KEM.
  </verify>
  <done>
Algorithm abstraction interfaces are defined. Registry pattern enables runtime algorithm selection. Algorithm identifiers cover current (ECDSA), transition, and target (ML-DSA/ML-KEM) algorithms.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Migration Roadmap and Hybrid Signature Format</name>
  <files>specifications/crypto/CRYPTO-AGILITY.md</files>
  <action>
Append to `specifications/crypto/CRYPTO-AGILITY.md`:

## 4. Migration Roadmap

### 4.1 Timeline Overview

```
                    2026        2027        2028        2029        2030+
                     |           |           |           |           |
Phase 1:         [=========]
Classical Only    ECDSA-secp256k1 or Ed25519 for all operations

Phase 2:                     [=======================]
Hybrid Signatures            ECDSA + ML-DSA dual-signature required
                             All new signatures use hybrid format

Phase 3:                                                 [=========>
PQC Primary                                              ML-DSA primary
                                                         Classical optional
```

### 4.2 Phase 1: Classical Only (Current - 2026)

**Configuration:**
```json
{
  "signaturePolicy": {
    "required": ["ECDSA-secp256k1"],
    "optional": [],
    "default": "ECDSA-secp256k1"
  },
  "kemPolicy": {
    "required": ["ECDH-X25519"],
    "optional": [],
    "default": "ECDH-X25519"
  }
}
```

**Verification Logic:**
- Accept: Single valid ECDSA signature
- Reject: Any other format

### 4.3 Phase 2: Hybrid Signatures (2027-2029)

**Rationale:**
- Hedge against both classical break AND PQC implementation bugs
- "Belt and suspenders" - signature valid only if BOTH algorithms verify
- Industry standard transition approach (NIST recommendation)

**Configuration:**
```json
{
  "signaturePolicy": {
    "required": ["ECDSA-secp256k1", "ML-DSA-65"],
    "optional": [],
    "default": "hybrid"
  },
  "kemPolicy": {
    "required": ["ECDH-X25519", "ML-KEM-768"],
    "optional": [],
    "default": "hybrid"
  }
}
```

**Verification Logic:**
- Accept: Both ECDSA AND ML-DSA signatures present and valid
- Reject: Only one signature present OR either signature invalid

### 4.4 Phase 3: PQC Primary (2030+)

**Configuration:**
```json
{
  "signaturePolicy": {
    "required": ["ML-DSA-65"],
    "optional": ["ECDSA-secp256k1"],
    "default": "ML-DSA-65"
  },
  "kemPolicy": {
    "required": ["ML-KEM-768"],
    "optional": ["ECDH-X25519"],
    "default": "ML-KEM-768"
  }
}
```

**Verification Logic:**
- Accept: Valid ML-DSA signature (with or without ECDSA)
- Reject: Only ECDSA present (classical-only not accepted)

## 5. Hybrid Signature Format

### 5.1 Signature Envelope

```typescript
/**
 * Hybrid signature envelope containing multiple algorithm signatures.
 * Each signature signs the SAME message hash.
 */
interface HybridSignature {
  /**
   * Version of the envelope format.
   * Enables future format evolution.
   */
  version: uint8;  // Current: 1

  /**
   * Array of algorithm-signature pairs.
   * Order: classical first, then PQC.
   */
  signatures: SignatureEntry[];
}

interface SignatureEntry {
  /**
   * Algorithm identifier from registry.
   */
  algorithmId: string;

  /**
   * Signature bytes for this algorithm.
   */
  signature: bytes;

  /**
   * Public key bytes (included for verification).
   */
  publicKey: bytes;
}
```

### 5.2 Encoding Format

```
Hybrid Signature Wire Format:

+--------+--------+--------+--------+--------+--------+
| Version| Count  | Entry 1 ...     | Entry 2 ...     |
| 1 byte | 1 byte | variable        | variable        |
+--------+--------+--------+--------+--------+--------+

Entry Format:
+--------+--------+--------+--------+--------+--------+
| AlgLen | AlgID  | SigLen | Signature        | PkLen  | PublicKey  |
| 1 byte | var    | 2 bytes| variable         | 2 bytes| variable   |
+--------+--------+--------+--------+--------+--------+
```

### 5.3 Verification Procedure

```typescript
function verifyHybridSignature(
  hash: bytes32,
  envelope: HybridSignature,
  registry: ICryptoRegistry,
  policy: SignaturePolicy
): boolean {
  // Check required algorithms are present
  const presentAlgorithms = new Set(envelope.signatures.map(s => s.algorithmId));
  for (const required of policy.required) {
    if (!presentAlgorithms.has(required)) {
      return false;  // Missing required algorithm
    }
  }

  // Verify each signature
  for (const entry of envelope.signatures) {
    if (!registry.isSupported(entry.algorithmId)) {
      // Unknown algorithm - skip if optional, fail if required
      if (policy.required.includes(entry.algorithmId)) {
        return false;
      }
      continue;
    }

    const verifier = registry.getVerifier(entry.algorithmId);
    if (!verifier.verify(hash, entry.signature, entry.publicKey)) {
      return false;  // Any invalid signature fails entire verification
    }
  }

  return true;
}
```

## 6. ERC-4337 Integration

### 6.1 Custom Signature Validation

ERC-4337 account abstraction enables custom signature schemes on Ethereum:

```solidity
// In Smart Account implementation
function _validateSignature(
    UserOperation calldata userOp,
    bytes32 userOpHash
) internal virtual returns (uint256 validationData) {
    // Decode hybrid signature envelope
    HybridSignature memory envelope = abi.decode(userOp.signature, (HybridSignature));

    // Get registry from trusted source
    ICryptoRegistry registry = getCryptoRegistry();
    SignaturePolicy memory policy = getCurrentPolicy();

    // Verify using crypto-agile pattern
    bool valid = verifyHybridSignature(userOpHash, envelope, registry, policy);

    return valid ? 0 : SIG_VALIDATION_FAILED;
}
```

### 6.2 Bundler Compatibility

Important considerations for bundlers:
- Larger signature sizes (ML-DSA-65: 3309 bytes vs ECDSA: 65 bytes)
- Gas cost estimation must account for PQC verification cost
- Bundlers should support hybrid signatures in mempool validation

## 7. Key Rotation Procedures

### 7.1 Product Key Rotation

Products may need key rotation without losing provenance chain:

```
Key Rotation Flow:

1. ANNOUNCE ROTATION
   - Emit KeyRotationInitiated event on-chain
   - Include old key hash, new key commitment
   - Grace period starts (7 days recommended)

2. DUAL-VALIDITY PERIOD
   - Both old and new keys accepted
   - New attestations use new key
   - Old attestations remain valid

3. COMPLETE ROTATION
   - Emit KeyRotationCompleted event
   - Old key deactivated for new signatures
   - Historical signatures remain valid

4. ARCHIVE OLD KEY
   - Store old public key in rotation history
   - Enable verification of historical signatures
   - Never delete - needed for provenance
```

### 7.2 Algorithm Upgrade Path

When upgrading from ECDSA to hybrid:

1. Register new PQC key alongside existing ECDSA key
2. Issue dual-key attestation linking old and new keys
3. Begin signing with hybrid format
4. Historical ECDSA-only signatures remain valid
5. Do NOT invalidate old signatures - products have 10+ year lifecycle

## 8. Implementation Notes

### 8.1 Library Recommendations

| Language | Classical | PQC |
|----------|-----------|-----|
| TypeScript | @noble/curves | @noble/post-quantum (when stable) |
| Rust | ring, ed25519-dalek | pqcrypto, oqs-rs |
| Solidity | ecrecover (native) | Precompile (future EIP) |
| Go | crypto/ecdsa | cloudflare/circl |

### 8.2 Performance Considerations

| Algorithm | Sign Time | Verify Time | Note |
|-----------|-----------|-------------|------|
| ECDSA-secp256k1 | ~50 us | ~100 us | Native EVM support |
| ML-DSA-65 | ~200 us | ~100 us | Comparable verify |
| SLH-DSA-128s | ~5 ms | ~500 us | Slower, larger sigs |

Hybrid adds overhead: expect 2x verify time during transition.

### 8.3 Storage Impact

Plan for larger key and signature storage:
- ECDSA public key: 33 bytes
- ML-DSA-65 public key: 1952 bytes
- ECDSA signature: 65 bytes
- ML-DSA-65 signature: 3309 bytes
- Hybrid signature: ~3400 bytes

Off-chain storage must accommodate larger cryptographic material.
  </action>
  <verify>
File contains "Migration Roadmap" section with three phases.
File contains "Hybrid Signature Format" section with wire format.
File contains "ERC-4337 Integration" section.
File contains "Key Rotation Procedures" section.
File contains phase timeline diagram showing 2026-2030 transition.
  </verify>
  <done>
Migration roadmap defines three-phase transition from classical to PQC. Hybrid signature format enables dual-verification during transition. ERC-4337 integration shows path for custom signatures on Ethereum. Key rotation procedures maintain provenance chain.
  </done>
</task>

</tasks>

<verification>
1. File exists at `specifications/crypto/CRYPTO-AGILITY.md`
2. Algorithm abstraction interfaces (ISignatureVerifier, IKeyEncapsulation, ICryptoRegistry) are complete
3. Algorithm identifier tables cover ECDSA, Ed25519, ML-DSA, and ML-KEM
4. Migration roadmap shows three phases (2026, 2027-2029, 2030+)
5. Hybrid signature format is specified with wire encoding
6. ERC-4337 integration path is documented
7. Key rotation procedures maintain historical signature validity
</verification>

<success_criteria>
- FOUND-06 requirement satisfied: Crypto-agile specification complete
- No cryptographic algorithms are hardcoded - all behind interfaces
- Migration path to NIST PQC standards is clear
- Hybrid signature period enables safe transition
- 10-year luxury product lifecycle is addressed
</success_criteria>

<output>
After completion, create `.planning/phases/02-architecture-foundation/02-02-SUMMARY.md`
</output>
